static const char *RcsId = "$Id: PhysValueTransformer.cpp,v 1.11 2017/03/31 13:30:41 perez Exp $";
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wago Modbus Tango Server
//  @ File Name : PhysValueTransformer.cpp
//  @ Date : 2013-02-03
//  @ Author : Pawel Kowaliszyn
//
//



#include "PhysValueTransformer.h"
#include "ModuleDB.h"

#include "Tools.h"
#include <cfloat>

/*!Default constructor
 *
 */
PhysValueTransformer::PhysValueTransformer():
referenceCtr(0)
{
}

/*!Transform binary value of module input to physical value.
 *
 * \param inputValuePtr	pointer to to binary value in buffer.
 * \param transformedValue	a place holder for transformed physical value.
 */
void PhysValueTransformer::TransformInput(unsigned short* inputValuePtr, float& transformedValue)
{
	transformedValue = (float)(*(short*)inputValuePtr);
}

/*!Transform binary value of module output to physical value.
 *
 * \param outputValuePtr	pointer to to binary value in buffer.
 * \param transformedValue	a place holder for transformed physical value.
 */
void PhysValueTransformer::TransformOutput(unsigned short* outputValuePtr, float& transformedValue)
{
	TransformInput(outputValuePtr,transformedValue);
}

/*!Transform given physical value to binary representation and write it pointed buffer
 *
 * \param outputValuePtr	pointer to position in buffer for binary value to be written.
 * \param transformedValue	physical value for transformation.
 */
void PhysValueTransformer::TransformOutputWrite(unsigned short* outputValuePtr, float& transformedValue)
{
	DB_DEBUG_STREAM << "PhysValueTransformer::TransformOutputWrite()" << endl;
	(*outputValuePtr) = (unsigned short)transformedValue;
}


/*!Default constructor
 *
 *\param numOfBits value bit size.
 *\param scallingFactorValue scalling factor by which value will be multiplied.
 *\param s indicates if value is signed or unsigned
 */
ConfigurableSizePhysTransformer::ConfigurableSizePhysTransformer(unsigned int numOfBits, float scallingFactorValue, bool s):
PhysValueTransformer(),
bits(numOfBits),
scallingFactor(scallingFactorValue),
sign(s)
{
}

/*!See PhysValueTransformer::TransformInput description
 *
 */
void ConfigurableSizePhysTransformer::TransformInput(unsigned short* inputValuePtr, float& transformedValue)
{
	long long long64;
	if (bits > 16)
		long64 = (long long)((unsigned short)(inputValuePtr[0]) + (unsigned short)(inputValuePtr[1])*65536);
	else
		long64 = (long long)(*inputValuePtr);


    long64 &= ((1LL<<bits)-1);
    if(long64& (1LL<<(bits-1)))
     long64 -= (1LL<<bits);
    transformedValue = (float)(long64) * scallingFactor;
}

/*!See PhysValueTransformer::TransformOutput description
 *
 */
void ConfigurableSizePhysTransformer::TransformOutput(unsigned short* outputValuePtr, float& transformedValue)
{
	TransformInput(outputValuePtr,transformedValue);
}

/*!See PhysValueTransformer::TransformOutputWrite description
 *
 */
void ConfigurableSizePhysTransformer::TransformOutputWrite(unsigned short* outputValuePtr, float& transformedValue)
{
	DB_DEBUG_STREAM << "ConfigurableSizePhysTransformer::TransformOutputWrite()" << endl;

	long long int integerVal = (long long int)(transformedValue/scallingFactor);

	if(bits == 32)
		if(sign)
			*((int*)(outputValuePtr)) = (int)(integerVal);
		else
			*((unsigned int*)(outputValuePtr)) = (unsigned int)(integerVal);
	else if(bits > 16)
		if(sign)
			*((int*)(outputValuePtr)) = ((int)(integerVal)) & ((1<<(bits+1))-1);
		else
			*((unsigned int*)(outputValuePtr)) = ((unsigned int)(integerVal)) &  ((1<<(bits+1))-1);
	else
		if(sign)
			*outputValuePtr = ((short)integerVal) & ((1<<(bits+1))-1);
		else
			*outputValuePtr = ((unsigned short)integerVal) & ((1<<(bits+1))-1);
}

/*!Default constructor
 *
 */
FsTransformer::FsTransformer():
PhysValueTransformer(),
scaleFactor(0),
MaxValue(0),
MinValue(0),
numberOfBitsToShift(0)
{
}

/*!See PhysValueTransformer::TransformInput description
 *
 */
void FsTransformer::TransformInput(unsigned short* inputValue, float& transformedValue)
{
	unsigned short tmp;

/*	if(overSizeBitPresent)
	{
		if((*inputValue) && 0x0002) //short cirquit flag
		{
			if((0x7fff>numberOfBitsToShift) && inputValue )
			{
				transformedValue = FLT_MAX;
				return;
			}
			else if((0x800>numberOfBitsToShift) && inputValue)
			{
				transformedValue = -FLT_MAX;
				return;
			}
		}
	}

	if(shortCutBitPresent)
	{
		if((*inputValue) && 0x0001) //overload flag
		{
			if((0x7fff>numberOfBitsToShift) && inputValue )
			{
				transformedValue = MaxValue + 0.1*MaxValue;
				return;
			}else if((0x800>numberOfBitsToShift) && inputValue)
			{
				transformedValue = -( MaxValue + 0.1*MaxValue);
				return;
			}
		}
	} */

	unsigned short sign =  (*inputValue) & 0x8000;
	tmp = (*inputValue) >> numberOfBitsToShift;
	if(sign)
	{
		tmp |= (0xffff - ((sign >> numberOfBitsToShift) - 1));
	}

	transformedValue = DequantizeSigned(tmp, (sizeof(short)*8)-numberOfBitsToShift);
}

/*!See PhysValueTransformer::TransformOutput description
 *
 */
void FsTransformer::TransformOutput(unsigned short* inputValue, float& transformedValue)
{
	TransformInput(inputValue,transformedValue);
}

/*!See PhysValueTransformer::TransformOutputWrite description
 *
 */
void FsTransformer::TransformOutputWrite(unsigned short* inputValue, float& transformedValue)
{
	DB_DEBUG_STREAM << "FsTransformer::TransformOutputWrite()" << endl;
	unsigned short tmp  = QuantizeSigned(transformedValue, (sizeof(short)*8)-numberOfBitsToShift);
	unsigned short sign = tmp & 0x8000;
	DB_DEBUG_STREAM << "FsTransformer::TransformOutputWrite() tmp:" << tmp << endl;
	DB_DEBUG_STREAM << "FsTransformer::TransformOutputWrite() numberOfBitsToShift:" << numberOfBitsToShift << endl;
	tmp = (tmp << numberOfBitsToShift);
	DB_DEBUG_STREAM << "FsTransformer::TransformOutputWrite() tmp:" << tmp << endl;
	tmp &= 0x7FFF;
	if(transformedValue != 0.0)
		tmp |= sign;
	*inputValue = tmp;
	DB_DEBUG_STREAM << "FsTransformer::TransformOutputWrite() value:" << *inputValue << endl;

}

/*!Method for initialization of transformer object with data from module description.
 *
 *\param modDescriptor reference to corresponding module description.
 *
 */
void FsTransformer::Setup(wagoModuleDesc &modDescriptor)
{

	if (strncmp(modDescriptor.special.c_str(), FS_RES, strlen(FS_RES)) != 0)
	{
		DB_ERROR_STREAM << "FsTransformer::Setup() Error while creating value transformation special parameter: "<< modDescriptor.modCode<< endl;
		EXCEPTION_RETURN("FsTransformer::Setup()"," Invalid module special(FS) parameter value", "Modbus::error_read");
	}

	DB_INFO_STREAM << "FsTransformer::Setup() for device module: " << modDescriptor.name << endl;

	float tmp = 0.0;
	float tmp2 = 0.0;
	int bits = 0;

	string tmpStr = modDescriptor.special.substr(strlen(FS_RES));
	vector<string> fields = string2vector(tmpStr, "-");
	int maxValuePos = 0;
	if(fields.size() > 1)
	{
		stringstream converter(fields[0]);
		converter >> this->MinValue;
		maxValuePos = 1;
	}
	fields = string2vector(fields[maxValuePos],"_");

	if(fields.size() > 1)
	{
		stringstream converter(fields[1]);
		unsigned int bits;
		converter >> bits;
		if( !bits || bits > 16)
		{
			DB_ERROR_STREAM << "FsTransformer::Setup() Error while creating value transformation invalid bit size, module: "<< modDescriptor.modCode<< endl;
			EXCEPTION_RETURN("FsTransformer::Setup()"," Invalid module special(FS) bit size value", "Modbus::error_read");
		}
		this->numberOfBitsToShift = 16 - bits;
	}

	stringstream converter(fields[0]);
	converter >> this->MaxValue;

	if(this->MinValue > this->MaxValue)
	{
		DB_ERROR_STREAM << "FsTransformer::Setup() Error while creating value transformation invalid min/max value, module: "<< modDescriptor.modCode<< endl;
		EXCEPTION_RETURN("FsTransformer::Setup()"," Invalid module special(FS) min/max value", "Modbus::error_read");
	}


	this->unipolar = false;
	if(modDescriptor.name.find("-UP") != std::string::npos)
		this->unipolar = true;

	this->scaleFactor = 0.0;
	switch(modDescriptor.modCode)
        {
	case 477://,    0, 0, 2, 0, 2, "fs20", "2 Channel 0/10V Differential Input",
	       DB_INFO_STREAM << "FsTransformer::Setup() special module: " << modDescriptor.name << endl;
	       this->scaleFactor = 1000;
               break;
        }
/*	switch(modDescriptor.modCode)
	{
	case 485://,    0, 0, 2, 0, 2, "fs4-20"/"fs20", "2 Channel 4/20mA Input",
	case 452://,    0, 0, 2, 0, 2, "fs20", "2 Channel 0/20mA Input",
//		this->numberOfBitsToShift = 3;
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = false;
		break;
	case 454://,    0, 0, 2, 0, 2, "fs4-20", "2 Channel 4/20mA Input",
//		this->numberOfBitsToShift = 3;
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = true;
		break;
	case 456://,    0, 0, 2, 0, 2, "fs10", "2 Channel +-10V Differential Input",
//		this->numberOfBitsToShift = 3;
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = false;
		break;
	case 457://,    0, 0, 4, 0, 4, "fs10", "4 Channel +-10V Input",
	case 465://,    0, 0, 2, 0, 2, "fs20", "2 Channel 0/20mA Input",
	case 466://,    0, 0, 2, 0, 2, "fs4-20", "2 Channel 4/20mA Input",
//		this->numberOfBitsToShift = 3;
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = true;
		break;
	case 467://,    0, 0, 2, 0, 2, "fs10", "2 Channel 0/10V Input",
	case 468://,    0, 0, 4, 0, 4, "fs10", "4 Channel 0/10V Input",
//		this->numberOfBitsToShift = 3;
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = false;
		break;
	case 472://,    0, 0, 2, 0, 2, "fs20", "2 Channel 0/20mA 16bit Input",
	case 474://,    0, 0, 2, 0, 2, "fs4-20", "2 Channel 4/20mA 16bit Input",
	case 476://,    0, 0, 2, 0, 2, "fs10", "2 Channel +-10V Input",
	case 477://,    0, 0, 2, 0, 2, "fs20", "2 Channel 0/10V Differential Input",
	case 478://,    0, 0, 2, 0, 2, "fs10", "2 Channel 0/10V Input",
//		this->numberOfBitsToShift = 0;
		this->overSizeBitPresent = false;
		this->shortCutBitPresent = false;
		break;
	case 479://,    0, 0, 2, 0, 2, "fs10", "2 Channel +-10V Input",
//		this->numberOfBitsToShift = 2;
		this->overSizeBitPresent = false;
		this->shortCutBitPresent = false;
		break;
	case 492://,    0, 0, 2, 0, 2, "fs4-20", "2 Channel 4/20mA Differential Input"
//		this->numberOfBitsToShift = 3;
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = true;
		break;
	case 550://,    0, 0, 0, 2, 2, "fs10", "2 Channel 0/10V Output",
	case 552://,    0, 0, 0, 2, 2, "fs20", "2 Channel 0/20mA Output",
	case 554://,    0, 0, 0, 2, 2, "fs4-20", "2 Channel 4/20mA Output",
	case 556://,    0, 0, 0, 2, 2, "fs10", "2 Channel +-10V Output",
	case 557://,    0, 0, 0, 4, 4, "fs10", "4 Channel +-10V Output",
//		this->numberOfBitsToShift = 0;	//These two goes to other transformer
		this->overSizeBitPresent = false;
		this->shortCutBitPresent = false;
		break;
	//case 750-562-UP://, 0, 0, 0, 2, 2, "fs10", "2 Channel 0/10V 16bit Output",
*//*	case 562://,    0, 0, 0, 2, 2, "fs10", "2 Channel +-10V 16bit Output",
		this->numberOfBitsToShift = 0;
		this->overSizeBitPresent = false;//These two goes to other transformer
		this->shortCutBitPresent = false;

		break;
		*//*
	case 459: //, 0, 0, 1, 0, 4, "none", "4 Channel Channel 0/10V Input"
//		this->numberOfBitsToShift = 3;	//These two goes to other transformer
		this->overSizeBitPresent = true;
		this->shortCutBitPresent = true;
	default:
		//Todo log unrecognized module
//		this->numberOfBitsToShift = 0;	//These two goes to other transformer
		this->overSizeBitPresent = false;
		this->shortCutBitPresent = false;
		break;
	}
*/
}

/*Method for conversion between binary 2-16bits signed value and float
 *
 * \param value	binary value to be converted.
 * \param bitSize	size of binary value in bits.
 *
 * \return converted float value.
 */
float FsTransformer::DequantizeSigned(short value, unsigned short bitSize)
{
    unsigned short N;
    float fvalue;

    float boundary = MaxValue- MinValue;
    DB_DEBUG_STREAM << "FsTransformer::DequantizeSigned() value: " << value << endl;
    DB_DEBUG_STREAM << "FsTransformer::DequantizeSigned() bitSize: " << bitSize << endl;
    DB_DEBUG_STREAM << "FsTransformer::DequantizeSigned() boundary: " << boundary << endl;
    DB_DEBUG_STREAM << "FsTransformer::DequantizeSigned() unipolar: " << unipolar << endl;
    DB_DEBUG_STREAM << "FsTransformer::DequantizeSigned() scaleFactor: " << scaleFactor << endl;
    fvalue = value;
    if(this->scaleFactor > 0) {
           return fvalue/scaleFactor;
    }
    if(unipolar == true) {
        N = (1 << (bitSize)) - 1;
	if(fvalue < 0.0)
        	fvalue = value + N + 1;
    } else {
 	N = (1 << (bitSize - 1)) - 1;
    }
    float tmp =  CLAMP<float>((fvalue / ((float)N /*+ 0.5*/))*boundary, -boundary, boundary);
    return tmp + MinValue;
}


/*Method for conversion between float and binary 2-16bits signed value.
 *
 * \param value	float value to be converted.
 * \param bitSize	size of binary value in bits.
 *
 * \return converted binary.
 */
unsigned short FsTransformer::QuantizeSigned(float value, unsigned short bitSize)
{
	 unsigned short N;
	 float sign;

	 float boundary = MaxValue- MinValue;
	 DB_DEBUG_STREAM << "FsTransformer::QuantizeSigned() bitSize: " << bitSize << endl;
	 DB_DEBUG_STREAM << "FsTransformer::QuantizeSigned() value: " << value << endl;
	 DB_DEBUG_STREAM << "FsTransformer::QuantizeSigned() boundary: " << boundary << endl;
	 DB_DEBUG_STREAM << "FsTransformer::QuantizeSigned() unipolar: " << unipolar << endl;
 	 if(unipolar == true) {
	 	N = (1 << (bitSize)) - 1;
	 	sign = 0;
	 } else {
	 	N = (1 << (bitSize - 1)) - 1;
	 	sign = (value >= 0) ? 0.5 : -0.5;
	 }

	 return (unsigned short)CLAMP<int>( (int)((value/boundary) * ((float)N + 0.5) + sign), -N, N);
}

/*!Default constructor
 *
 */
ThcTransformer::ThcTransformer():
PhysValueTransformer()
{
}

/*!See PhysValueTransformer::TransformInput description
 *
 */
void ThcTransformer::TransformInput(unsigned short* inputValue, float& transformedValue)
{
	short signedValue = *(short*)inputValue;
	transformedValue = ((float)signedValue) * 0.1f;
}

/*!See PhysValueTransformer::TransformOutput description
 *
 */
void ThcTransformer::TransformOutput(unsigned short* inputValue, float& transformedValue)
{
	short signedValue = *(short*)inputValue;
	transformedValue = ((float)signedValue) * 0.1f;
}

/*!See PhysValueTransformer::TransformOutputWrite description
 *
 */
void ThcTransformer::TransformOutputWrite(unsigned short* inputValue, float& transformedValue)
{
	DB_DEBUG_STREAM << "ThcTransformer::TransformOutputWrite()" << endl;
	*inputValue  = (unsigned short)(transformedValue*10.0f);
}

/*!Default constructor
 *
 */
SSITransformer::SSITransformer():
PhysValueTransformer(),
bits(0)
{
}

/*!Method for initialization of transformer object with data from module description.
 *
 *\param modDescriptor reference to corresponding module description.
 *
 */
void SSITransformer::Setup(wagoModuleDesc& modDescriptor)
{
	unsigned int tmp;
	if (sscanf(modDescriptor.special.c_str() + strlen(SSI_RES), "%d", &tmp) != 1)
	{
		DB_ERROR_STREAM << "SSITransformer::Setup() Error while creating value transformation object invalid SSI description parameter, module: "<< modDescriptor.modCode<< endl;
		EXCEPTION_RETURN("SSITransformer::Setup"," Invalid module special(SSI)", "Modbus::error_read");
	}
	if(tmp > (modDescriptor.ana_in*16) )
	{
		DB_ERROR_STREAM << "SSITransformer::Setup() Error while creating value transformation object  invalid number of bits, module: "<< modDescriptor.modCode<< endl;
		EXCEPTION_RETURN("SSITransformer::Setup"," Invalid module special(SSI) bit size", "Modbus::error_read");
	}

	this->bits =tmp;
}

/*!See PhysValueTransformer::TransformInput description.
 *
 */
void SSITransformer::TransformInput(unsigned short* inputValue, float& transformedValue)
{
	transformedValue = 0;
	long long long64 = (long long)( *(inputValue +1) + (*inputValue * 65536));
	long64 &= ((1LL << bits) - 1);
	if (long64 & (1LL << (bits - 1)))
		long64 -= (1LL << bits);
	transformedValue = (float) (long64);
}

/*!See PhysValueTransformer::TransformOutput description.
 *
 */
void SSITransformer::TransformOutput(unsigned short* inputValue, float& transformedValue)
{
	return;
}

/*!See PhysValueTransformer::TransformOutputWrite description.
 *
 */
void SSITransformer::TransformOutputWrite(unsigned short* inputValue, float& transformedValue)
{
	DB_DEBUG_STREAM << "SSITransformer::TransformOutputWrite()" << endl;
	return;
}
