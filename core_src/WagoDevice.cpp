static const char *RcsId = "$Id: WagoDevice.cpp,v 1.8 2016/08/26 14:48:02 perez Exp $";
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wago Modbus Tango Server
//  @ File Name : WagoDevice.cpp
//  @ Date : 2013-02-03
//  @ Author : Pawel Kowaliszyn
//
//


#include "WagoDevice.h"
#include "ModuleDB.h"
#include "Services.h"

/*!Default constructor
 *
 */
WagoDevice::WagoDevice()
{
	buffers.SetWagoDevice(this);
}

/*!Default destructor
 *
 */
WagoDevice::~WagoDevice()
{
	unsigned int i;

	INFO_STREAM << "~WagoDevice: cleaning up modules!" <<endl;
	for(i= 0; i < modules.size(); i++)
			delete modules[i];


	INFO_STREAM << "~WagoDevice: cleaning up logical devices!" <<endl;
	for(i= 0; i < logicalDevices.size(); i++)
			delete logicalDevices[i];

}

/*! Read physical values of given logical device directly from the device (ommit cache).
 *
 * \param LDeviceKey	numeric key of requested logical device.
 * \param values		reference to container for output values.
 */
void WagoDevice::ReadPhysNoCache(unsigned short LDeviceKey, vector<float> &values)
{
	if(buffers.TryReadLock()) //check if there is ongoing buffer update;
	{
		buffers.ReadUnlock();
		buffers.UpdateProcessImage(); //
	}


	if(LDeviceKey >= logicalDevices.size())
	{
		EXCEPTION_RETURN("WagoDevice::ReadPhysNoCache"," invalid device Key", "Modbus::error_read");
	}

	buffers.ReadLock();

	try{
		buffers.ValidateImage();
		logicalDevices[LDeviceKey]->ReadPhys(values);
	}catch(...)
	{
		buffers.ReadUnlock();
		throw;
	}

	buffers.ReadUnlock();
}

/*! Write physical values to a given logical device (with use of catche).
 *
 * \param LDeviceKey	numeric key of requested logical device.
 * \param values		reference to container holding values for write.
 */
void WagoDevice::WritePhys(unsigned short LDeviceKey, vector<float> &values)
{
	if(LDeviceKey >= logicalDevices.size())
	{
		ERROR_STREAM << "WagoDevice::WritePhys() invalid device Key" << endl;
		EXCEPTION_RETURN("WagoDevice::WritePhys","invalid device Key", "Modbus::error_write");
	}
	
	buffers.WriteLock();
	try{
		logicalDevices[LDeviceKey]->WritePhys(values);
		buffers.UploadOutputs();
	}catch( ... )
	{
		buffers.CancelWrite();
		buffers.WriteUnlock();
		throw;
	}

	buffers.WriteUnlock();
}

/*! Read physical values of given logical device (with use of catche).
 *
 * \param LDeviceKey	numeric key of requested logical device.
 * \param values		reference to container for output values.
 */
void WagoDevice::ReadPhys(unsigned short LDeviceKey, vector<float> &values)
{

	if(LDeviceKey >= logicalDevices.size())
	{
		ERROR_STREAM << "WagoDevice::ReadPhys() invalid device Key" << endl;
		EXCEPTION_RETURN("WagoDevice::ReadPhys","invalid device Key", "Modbus::error_read");
	}

	buffers.ReadLock();
	try{
		buffers.ValidateImage();
		logicalDevices[LDeviceKey]->ReadPhys(values);
	}catch(...)
	{
		buffers.ReadUnlock();
		throw;
	}
	buffers.ReadUnlock();
}

/*! Read binary values of given logical device (with use of catche).
 *
 * \param LDeviceKey	numeric key of requested logical device.
 * \param values		reference to container for output values.
 */
void WagoDevice::ReadDigi(unsigned short LDeviceKey, vector<unsigned short> &values)
{

	if(LDeviceKey >= logicalDevices.size())
	{
		ERROR_STREAM << "WagoDevice::ReadDigi() invalid device Key" << endl;
		EXCEPTION_RETURN("WagoDevice::ReadDigi","invalid device Key", "Modbus::error_read");
	}

	buffers.ReadLock();
	try{
	buffers.ValidateImage();
	logicalDevices[LDeviceKey]->ReadDigi(values);
	}catch(...)
	{
		buffers.ReadUnlock();
		throw;
	}
	buffers.ReadUnlock();
}

/*! Read binary values of given logical device directly from the device (ommit cache).
 *
 * \param LDeviceKey	numeric key of requested logical device.
 * \param values		reference to container for output values.
 */
void WagoDevice::ReadDigiNoCache(unsigned short LDeviceKey, vector<unsigned short> &values)
{

	if(buffers.TryReadLock()) //check if there is ongoing buffer update;
	{
		buffers.ReadUnlock();
		buffers.UpdateProcessImage(); //
	}


	if(LDeviceKey >= logicalDevices.size())
	{
		ERROR_STREAM << "WagoDevice::ReadReadDigiNoCache() invalid device Key" << endl;
		EXCEPTION_RETURN("WagoDevice::ReadReadDigiNoCache"," invalid device Key", "Modbus::error_read");
	}

	buffers.ReadLock();

	try{
		buffers.ValidateImage();
		logicalDevices[LDeviceKey]->ReadDigi(values);
	}catch(...)
	{
		buffers.ReadUnlock();
		throw;
	}
	buffers.ReadUnlock();
}

/*! Write digital values to a given logical device (with use of catche).
 *
 * \param LDeviceKey	numeric key of requested logical device.
 * \param values		reference to container holding values for write.
 */
void WagoDevice::WriteDigi(unsigned short LDeviceKey, vector<unsigned short> &values)
{
	if(LDeviceKey >= logicalDevices.size())
	{
		ERROR_STREAM << "WagoDevice::WriteDigi() invalid device Key" << endl;
		EXCEPTION_RETURN("WagoDevice::WriteDigi","invalid device Key", "Modbus::error_write");
	}

	buffers.WriteLock();
	try{
		logicalDevices[LDeviceKey]->WriteDigi(values);
		buffers.UploadOutputs();
	}catch(...)
	{
		buffers.CancelWrite();
		buffers.WriteUnlock();
		throw;
	}
	buffers.WriteUnlock();
}

/*! Write all numerical keys of logical devices aggregated by this object to a given containter.
 *
 * \param values		reference to container for values.
 */
void WagoDevice::ReadKeys(vector<unsigned short> &values)
{
	for(unsigned int i = 0; i < logicalDevices.size(); i++)
		values.push_back(i);
}

/*! Find and return name of logical device given by its logical device key.
 *
 * \param LDeviceKey	numerical logical device key.
 * \param name			a place holder for name of the requested device.
 */
void WagoDevice::Key2Name(unsigned short LDeviceKey, string &name)
{
	if(LDeviceKey >= logicalDevices.size())
	{
		ERROR_STREAM << "WagoDevice::Key2Name() invalid logical channel Key" << endl;
		EXCEPTION_RETURN("WagoDevice::Key2Name","invalid logical channel Key", "Modbus::error_read");
	}

	name = logicalDevices[LDeviceKey]->GetName();
}

/*! Find and return logical device key of logical device given by its name.
 *
 * \param name	name of requested logical device.
 * \param key			a place holder numerical key of the requested device.
 */
void WagoDevice::Name2Key(string &name, unsigned short &key)
{
	for(unsigned int i = 0; i < logicalDevices.size(); i++)
	{
		if(name == logicalDevices[i]->GetName())
		{
			key = i;
			return;
		}
	}

	ERROR_STREAM << "WagoDevice::Name2Key() invalid logical channel name" << endl;
	EXCEPTION_RETURN("WagoDevice::Name2Key","invalid logical channel name", "Modbus::error_read");
}

/*!Method for conducting log2hard service.
 *
 *\param  LDeviceKey key of requested logical device.
 *\param  LChannel	channel of requested logical device.
 *\param  values	a place holder for service returned values.
 */
void WagoDevice::Log2Hard(unsigned short LDeviceKey, unsigned short LChannel, vector<unsigned short> &values)
{
	Visitor* service = new Log2HardService(LDeviceKey,LChannel, &values);
	LOGGING_INITIALIZE_ADDON(service);
	ConductService(service);

}

/*!Method for conducting hard2log service.
 *
 *\param  offset	process image offset of requested module channel.
 *\param  io		type of requested module.
 *\param  valueHolder	a place holder for returned values.
 */
void WagoDevice::Hard2LOG(unsigned short offset, unsigned short io, vector<unsigned short>& valueHolder)
{
	Visitor* service = new Hard2LogService(offset, io, &valueHolder);
	LOGGING_INITIALIZE_ADDON(service);
	ConductService(service);
}

/*!Method for conducting WcComm service.
 *
 *\param  inputArguments	service input values.
 *\param  outputArguments	a place holder for returned values.
 */
void WagoDevice::WcComm(vector<unsigned short>& inputArguments, vector<unsigned short>& outputArguments)
{
	Visitor* service = new WcCommService(&inputArguments, &outputArguments);
	LOGGING_INITIALIZE_ADDON(service);
	ConductService(service);
}

/*!Method for conducting Status service.
 *
 *\param  output	a place holder for generated status message.
 */
void WagoDevice::Status(string &output)
{
	Visitor* service = new StatusService(&output);
	LOGGING_INITIALIZE_ADDON(service);
	ConductService(service);
}

/*!Generic for conducting Visitor class based services.
 *
 *\param  service	pointer to service object to be processed.
 */
void WagoDevice::ConductService(Visitor* service)
{
	try{
		service->VisitWagoDevice(this);
	}catch(...)
	{
		delete service;
		throw;
	}
	delete service;
}

/*!Return pointer to wago Module object given by its number.
 *
 *\param  number	number of wago module.
 *\return	pointer to found object otherwise NULL.
 */
Module* WagoDevice::GetModule(unsigned int number)
{
	if(number >= modules.size())
		return NULL;
	return modules[number];
};

/*!Return pointer to logical device object given by its number.
 *
 *\param  number	number of logical device.
 *\return	pointer to found object otherwise NULL.
 */
LogicalDevice* WagoDevice::GetLd(unsigned int number)
{
	if(number >= logicalDevices.size())
		return NULL;
	return logicalDevices[number];
};

/*!Get order number of given wago module object.
 *
 *\param  mod	pointer to the wago module object.
 *\return	order number of object(if invalid module pointer -1).
 */
int WagoDevice::GetModuleIndex(Module* mod)
{
	for(unsigned int i = 0; i < modules.size(); i++)
	{
		if( mod == modules[i])
			return i;
	}

	return -1;
}

/*!Check if wago module structure from given configuration matches module list in this object.
 *
 *\param  cfg	configuration of wago controller/coupler.
 *\return	true if configuration matches physical module alignment.
 */
bool WagoDevice::ValidateConfiguration(configInfo& cfg)
{
	unsigned int i,j;
	stringstream ss;

	DEBUG_STREAM <<  "WagoDevice::ValidateConfiguration() called " << endl;

	for(i= 0; i < cfg.modules.size() && i < modules.size(); i++)
	{
		if( cfg.modules[i] & 0x8000 )
			continue;

		ss << cfg.seriesCode << "-" << cfg.modules[i] ;
		DEBUG_STREAM << cfg.seriesCode << "-" << cfg.modules[i] << endl;
		if(ss.str() != modules[i]->GetModuleDescriptor()->name.substr(0,ss.str().size())) 
			return false;

		ss.str("");
	}

	if( i >= cfg.modules.size() &&   i < modules.size() )
	{
		ERROR_STREAM << "WagoDevice::ValidateConfiguration() number of modules in config and seen by controller does not match " << endl;
		return false;
	}

	return true;
}
