static const char *RcsId = "$Id: LogicalDevice.cpp,v 1.6 2015/04/07 13:13:57 perez Exp $";
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wago Modbus Tango Server
//  @ File Name : LogicalDevice.cpp
//  @ Date : 2013-02-03
//  @ Author : Pawel Kowaliszyn
//
//


#include "LogicalDevice.h"
#include "Module.h"

/*! ReadPhys returns physical values of the logical device. Physical values are values of
 * corresponding variables of wago controller modules which are transformed according
 * to specification and representing actual value of measured property.
 *
 * \param values	a placeholder for read result.
 */
void LogicalDevice::ReadPhys(vector<float>& values)
{
	float tmp;
	int ret;
	for(unsigned int i = 0 ; i < logicalChannels.size(); i++)
	{

		/*
		 * NOTE MP 7/Apr/2015: try to handle modules having several type of I/O
		 * for instance with modules 507 or 508 having DIGI_OUT and DIGI_IN, 
		 * 
		 * As, until now, the only problematic modules found were output modules
		 * with extra DIGI_IN for status purpose, let's simply ignore 
		 * these DIGI_INs
		 * 
		 * Of course, for the reverse problematic modules (input modules with
		 * extra DIGI_OUT), this patch will not work. But let's wait for
		 * these modules.
		 */
		if(!(ret = logicalChannels[i].module->ReadPhysOut(logicalChannels[i].channel, tmp)))
			values.push_back(tmp);
		if(ret && !logicalChannels[i].module->ReadPhysIn(logicalChannels[i].channel, tmp))
			values.push_back(tmp);
	}
}

/*! WritePhys writes given physical values of logical Device into corresponding modules of wago controller.
 *  Walues are converted to binary values before writing.
 *
 * \param values	values for writing.
 */
void LogicalDevice::WritePhys(vector<float>& values)
{
	if(values.size()%2) // vaules must be submitted in pairs (logicalDeviceNumber - value)
	{
		ERROR_STREAM << "LogicalDevice::WritePhys() - Invalid write values count logicalDevice: " << this->name << endl;
		EXCEPTION_RETURN("LogicalDevice::WritePhys","Invalid write value count", "Modbus::error_write");
	}

	for(unsigned int i = 0 ; i < values.size(), i < values.size(); i=i+2)
	{
		unsigned int lchNumber = (unsigned int)values[i];
		if(lchNumber >= logicalChannels.size())
		{
			EXCEPTION_RETURN("LogicalDevice::WritePhys","invalid logical channel number", "Modbus::error_write");
		}
		logicalChannels[lchNumber].module->WritePhys(logicalChannels[lchNumber].channel, values[i+1]);
	}
}

/*! ReadDigi returns raw binary values of the logical device.
 *
 * \param values	a placeholder for read result.
 */
void LogicalDevice::ReadDigi(vector<unsigned short>& values)
{
	for(unsigned int i = 0 ; i < logicalChannels.size(); i++)
	{
		logicalChannels[i].module->ReadDigiIn(logicalChannels[i].channel, values);
		logicalChannels[i].module->ReadDigiOut(logicalChannels[i].channel, values);
	}
}

/*! WriteDigi writes given raw binary values of logical Device into corresponding modules of wago controller.
 *
 * \param values	values for writing.
 */
void LogicalDevice::WriteDigi(vector<unsigned short>& values)
{

	if(values.size()%2 || values.empty()) // vaules must be submitted in pairs (logicalDeviceNumber - value)
	{
		ERROR_STREAM << "WriteDigi - Invalid write values count logicalDevice: " << this->name << endl;
		EXCEPTION_RETURN("LogicalDevice::WriteDigi","Invalid write value count", "Modbus::error_write");
	}

	unsigned int lchNumber = values[0];
	if(lchNumber >= logicalChannels.size())
	{
		EXCEPTION_RETURN("LogicalDevice::WritePhys","invalid logical channel number", "Modbus::error_write");
	}

	vector<unsigned short>  dataValues;
	for(unsigned int i = 0; i < values.size(); i= i + 2)
	{

		if( lchNumber != values[i] )
		{
			logicalChannels[lchNumber].module->WriteDigi(logicalChannels[lchNumber].channel, dataValues);
			dataValues.clear();
			lchNumber = values[i];
			if(lchNumber >= logicalChannels.size())
			{
				EXCEPTION_RETURN("LogicalDevice::WritePhys","invalid logical channel number", "Modbus::error_write");
			}
		}

		dataValues.push_back(values[i+1]);

	}
	if(!dataValues.empty())
		logicalChannels[lchNumber].module->WriteDigi(logicalChannels[lchNumber].channel, dataValues);


}

/*! GetChannel returns pointer to mapping object (which describes channel of the logical device)
 * represented by given index
 *
 * \param chan	channel index.
 *
 * \return	pointer to found object or NULL.
 */
logDeviceValueMapping* LogicalDevice::GetChannel(unsigned int chan)
{
	if(chan >= logicalChannels.size())
		return NULL;

	return &(logicalChannels[chan]);
};

