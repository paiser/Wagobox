static const char *RcsId = "$Id: Module.cpp,v 1.7 2015/11/03 15:36:34 perez Exp $";
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wago Modbus Tango Server
//  @ File Name : Module.cpp
//  @ Date : 2013-02-03
//  @ Author : Pawel Kowaliszyn
//
//


#include "Module.h"

/*!Default constructor
 *
 */
Module::Module():
inputBaseAddr(NULL),
outputBaseAddr(NULL),
outputBaseWriteAddr(NULL),
outputWriteFlags(NULL),
numberOfChannels(0),
numberOfInputs(0),
numberOfOutputs(0),
moduleDescriptor(0),
inputOffset(0),
outputOffset(0)
{
}

/*! Read physical value of input channel.
 *
 * \param channel	channel number to be read from.
 * \param values	a place holder for read values.
 */
int Module::ReadPhysIn(unsigned short channel, float& values)
{
	float tmpVal;
	if(!inputBaseAddr)
		return -1;

	unsigned int offset = channel*numberOfInputs;
	DEBUG_STREAM << "Module::ReadPhysIn offset: " << offset << endl;
	moduleDescriptor->physTransformer->TransformInput((unsigned short*)(inputBaseAddr +	offset), values);
	return 0;
}

/*!Destructor informs ModuleDB object that this module is beeint destroyed.
 *
 */
Module::~Module()
{
	ModuleDB::Instance()->DereferenceModule(moduleDescriptor);
}

/*! Read physical value of output channel.
 *
 * \param channel	channel number to be read from.
 * \param values	a place holder for read values.
 */
int Module::ReadPhysOut(unsigned short channel, float& values)
{
	float tmpVal;
	if(!outputBaseAddr)
		return -1;

	unsigned int offset = channel*numberOfOutputs;
	DEBUG_STREAM << "Module::ReadPhysOut  offset: " << offset << endl;
	moduleDescriptor->physTransformer->TransformOutput((unsigned short*)(outputBaseAddr +	offset), values);
	return 0;
}

/*! Write physical value to output channel.
 *
 * \param channel	channel number to be read from.
 * \param values	values for write.
 */
void Module::WritePhys(unsigned short channel, float& values)
{
	if(!numberOfOutputs)
	{
		ERROR_STREAM << "WritePhys attempt on module " << this->moduleDescriptor->modCode << " module has no outputs."<< endl;
		EXCEPTION_RETURN("Module::WritePhys"," Module has no otputs", "Modbus::error_write");
	}

	unsigned int offset = channel*numberOfOutputs;
	INFO_STREAM << "Module::WritePhys:"   << endl;
        INFO_STREAM << "    module:"          << this->moduleDescriptor->modCode << endl;
        INFO_STREAM << "    numberOfOutputs:" << numberOfOutputs+1 <<endl;
	INFO_STREAM << "    baddr:"           << this->outputOffset << endl;
        INFO_STREAM << "    offset:"          << offset <<  endl;
        INFO_STREAM << "    value:"           << values <<endl;
	moduleDescriptor->physTransformer->TransformOutputWrite((unsigned short*)(outputBaseWriteAddr +	offset), values);

	for(unsigned int i = 0 ; i < numberOfOutputs ; i++ )
		*(outputWriteFlags+offset+i) = true;


}

/*! Read binary value from input channel.
 *
 * \param channel	channel number to be read from.
 * \param values	a place holder for read values.
 */
void Module::ReadDigiIn(unsigned short channel, vector<unsigned short>& values)
{
	unsigned int i;
	unsigned int offset =channel*numberOfInputs;
	for(i = 0; i < numberOfInputs; i++ )
		values.push_back(*(unsigned short*)(inputBaseAddr +offset+i));
	DEBUG_STREAM << "Module::ReadDigiIn offset: " << offset << endl;
}

/*! Read binary value from output channel.
 *
 * \param channel	channel number to be read from.
 * \param values	a place holder for read values.
 */
void Module::ReadDigiOut(unsigned short channel, vector<unsigned short>& values)
{
	unsigned int i;
	unsigned int offset =channel*numberOfOutputs;
	for(i = 0; i < numberOfOutputs; i++ )
		values.push_back(*(unsigned short*)(outputBaseAddr +offset+i));
	DEBUG_STREAM << "Module::ReadDigiOut offset: " << offset << endl;

}

/*! Write binary value to output channel.
 *
 * \param channel	channel number to be read from.
 * \param values	values for write.
 */
void Module::WriteDigi(unsigned short channel, vector<unsigned short>& values)
{
	if(!numberOfOutputs)
	{
		ERROR_STREAM << "WriteDigi attempt on module " << this->moduleDescriptor->modCode << ", module has no outputs."<< endl;
		EXCEPTION_RETURN("Module::WriteDigi"," Module has no otputs", "Modbus::error_write");
	}

	unsigned int offset = channel*numberOfOutputs;

	for(unsigned int i = 0; i < numberOfOutputs; i++)
	{
		if(i >= values.size() )
			*(unsigned short*)(outputBaseWriteAddr + offset + i) = 0x0;
		else
			*(unsigned short*)(outputBaseWriteAddr + offset + i) = values[i];

		*(outputWriteFlags + offset + i) = true;
	}
	DEBUG_STREAM << "Module::WriteDigi offset: " << offset << " numberOfOutputs: " << numberOfOutputs << endl;
}

/*! Check if given memory address is within addres range of module channel in process image buffer.
 *
 * \param addr		addres of for checking.
 * \param channel	channel for checking.
 *
 * \return true if address is within addr range of given channel else false.
 */
bool Module::IsWithinAddresRange(unsigned short* addr, unsigned int channel)
{
	unsigned short* channelBase = this->inputBaseAddr + channel*numberOfInputs;
	if((addr >= channelBase) && (addr < (channelBase+numberOfInputs)))
		return true;

	channelBase = this->outputBaseAddr + channel*numberOfOutputs;
	if((addr >= channelBase) && (addr < (channelBase+numberOfOutputs)))
		return true;

	return false;
}

/*! Get offset in process image of channel input.
 *
 * \param channel	channel number of the module.
 * \return requested offset
 */
unsigned short Module::GetInputOffset(unsigned short channel)
{
	//TODO channel validation ?
	DEBUG_STREAM << "Module::GetInputOffset() channel: " << channel << " numberOfOutputs: " << this->numberOfOutputs << endl;
	return inputOffset + channel*this->numberOfInputs;
};

/*! Get offset in process image of channel output.
 *
 * \param channel	channel number of the module.
 * \return requested offset
 */
unsigned short Module::GetOutputOffset(unsigned short channel)
{
	//TODO channel validation ?
	DEBUG_STREAM << "Module::GetOutputOffset() channel: " << channel << " numberOfOutputs: " << this->numberOfOutputs << endl;
	return outputOffset + channel*this->numberOfOutputs;
};

/*! Default constructor.
 *
 */
M637Module::M637Module():
	Module()
{
}

/*! Method overload for 637 module. See Module::ReadPhysIn.
 *
 */
int M637Module::ReadPhysIn(unsigned short channel, float& values)
{
	unsigned short buff[2];
	if( channel = 0 ) //reading status bytes
	{
		buff[0] = inputBaseAddr[0];
		buff[1] = inputBaseAddr[2];
	}
	else //reading encoder value
	{
		buff[0] = inputBaseAddr[1];
		buff[1] = inputBaseAddr[3];
	}

	moduleDescriptor->physTransformer->TransformInput(buff, values);

	return 0;
}

/*! Method overload for 637 module. This module has
 * input and output registers. Method returns -1 to
 * to allow read only input registers.
 *
 */
int M637Module::ReadPhysOut(unsigned short channel, float& values)
{
	return -1;
}

/*! Method overload for 637 module. See Module::WritePhys
 *
 */
void M637Module::WritePhys(unsigned short channel, float& values)
{
	unsigned short buff[2];
	moduleDescriptor->physTransformer->TransformOutputWrite(buff, values);
	if( channel = 0 ) //reading status bytes
	{
		inputBaseAddr[0] = buff[0];
		inputBaseAddr[2] = buff[1];
	}
	else //reading encoder value
	{
		inputBaseAddr[1] = buff[0];
		inputBaseAddr[3] = buff[1];
	}

}

/*! Method overload for 637 module. See Module::WriteDigi
 *
 */
void M637Module::WriteDigi(unsigned short channel, vector<unsigned short>& values)
{
	if(values.size() < 2)
		EXCEPTION_RETURN("M637Module::WriteDigi","2 values needed for channel write", "Modbus::error_write");

	if( channel = 0 ) //reading status bytes
	{
		inputBaseAddr[0] = values[0];
		inputBaseAddr[2] = values[1];
	}
	else //reading encoder value
	{
		inputBaseAddr[1] = values[0];
		inputBaseAddr[3] = values[1];
	}
}

/*! Method overload for 637 module. See Module::ReadDigiIn
 *
 */
void M637Module::ReadDigiIn(unsigned short channel, vector<unsigned short>& values)
{
	values.resize(2);
	if( channel = 0 ) //reading status bytes
	{
		values[0] = inputBaseAddr[0];
		values[1] = inputBaseAddr[2];
	}
	else //reading encoder value
	{
		values[0] = inputBaseAddr[1];
		values[1] = inputBaseAddr[3];
	}
}

/*! Method overload for 637 module. This module has
 * input and output registers. Method returns -1 to
 * to allow read only input registers.
 *
 */
void M637Module::ReadDigiOut(unsigned short channel, vector<unsigned short>& values)
{
	return;
}
