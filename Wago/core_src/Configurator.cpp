static const char *RcsId = "$Id: Configurator.cpp,v 1.14 2015/01/29 15:27:02 perez Exp $";
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wago Modbus Tango Server
//  @ File Name : Configurator.cpp
//  @ Date : 21/03/2013
//  @ Author : Pawel Kowaliszyn
//
//


#include "Configurator.h"
#include "WagoDevice.h"
#include "PhysValueTransformer.h"

#include <algorithm>

/*!Constructor.
 *
 * \param wdev	pointer to Wago device object for set up.
 */
Configurator::Configurator(WagoDevice *wdev):
wd(wdev),
currentAnaInOffset(0),
currentAnaOutOffset(0),
currentBinaryInOffset(0),
currentBinaryOutOffset(0),
configValid(false)
{

}

/*! This method starts the setup process. Configuration is parsed
 * and wago device data tree is created according to configuration.
 *
 * \param resources reference to voector of strings holding configuration.
 * 					Each line holds name of module name, and list of logica devices
 * 					assigned to channels of module.
 *
 * 					example:
 * 						750-517,dout1,dout2
 *						750-469,Temp1,Temp2
 *						750-469,Temp3,Temp4
 *						750-469,Temp5,Temp6
 *						750-469,Temp7,Temp8
 *						750-469,Temp9,Temp10
 */
void Configurator::ParseConfiguration(vector<string> &resources)
{
	try{
		for(unsigned int i = 0 ; i < resources.size(); i++ )
		{
			string tmp = resources[i];
			tmp.erase( std::remove_if( tmp.begin(), tmp.end(), ::isspace ), tmp.end() ); // remove whitespaces from line
			vector<string> fields = string2vector(tmp, ",");
			ParseConfigLine(fields);
		}
		configValid = true;
	}catch(...)
	{
		for(unsigned int i = 0; i < wd->modules.size(); i++)
			delete wd->modules[i];
		wd->modules.clear();

		for(unsigned int i = 0; i < wd->logicalDevices.size(); i++)
			delete wd->logicalDevices[i];
		wd->logicalDevices.clear();

		currentAnaInOffset = 0;
		currentAnaOutOffset = 0;
		currentBinaryInOffset = 0;
		currentBinaryOutOffset = 0;

		throw;
	}

	SetupBuffers();

}

/* Parse line of configuration. Creates and setup module objects, corresponding
 *  logical device objects and does the setup of logical device mapping.
 *
 * \param lineVals	reference to vector of strings holding splited content
 * 					of configuration line.
 * \return if linevals are empty returns -1.
 */
int Configurator::ParseConfigLine(vector<string> &lineVals)
{
	if(lineVals.empty())
		return -1;

	wagoModuleDesc* dsc = ModuleDB::Instance()->FindModule(lineVals[0]);
	if(!dsc)
	{
		ERROR_STREAM << "Invalid Module type in configuration attribute module: " << lineVals[0] << endl;
		EXCEPTION_RETURN("Configurator::ParseConfigLine"," Unknown module(not present in moduleCatalogue) name: " + lineVals[0] , "Modbus::error_read");
	}

	ModuleDB::Instance()->ReferenceModule(dsc);

	Module* mod;

	if(dsc->ana_in || dsc->ana_out)
	{
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  RegisterModule " << lineVals[0] << endl;
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  dsc->channels: " << dsc->channels << endl;
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  dsc->digi_in: " << dsc->ana_in << endl;
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  dsc->digi_out: " << dsc->ana_out << endl;

		mod = CreateRegisterModule(dsc);
		mod->inputOffset = currentAnaInOffset;
		mod->outputOffset = currentAnaOutOffset;
		currentAnaInOffset += dsc->ana_in*dsc->channels;
		currentAnaOutOffset += dsc->ana_out*dsc->channels;
	}
	else if(dsc->digi_in || dsc->digi_out)
	{
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  BinaryModule " << lineVals[0] << endl;
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  dsc->channels: " << dsc->channels << endl;
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  dsc->digi_in: " << dsc->digi_in << endl;
		DEBUG_STREAM << "Configurator::ParseConfigLine creating  dsc->digi_out: " << dsc->digi_out << endl;

		mod = CreateBinaryModule(dsc);
		mod->inputOffset = currentBinaryInOffset;
		mod->outputOffset = currentBinaryOutOffset;
		currentBinaryInOffset += dsc->digi_in*dsc->channels;
		currentBinaryOutOffset += dsc->digi_out*dsc->channels;
	}

	mod->moduleDescriptor = dsc;

	if(mod->numberOfChannels < lineVals.size()-1) //check if module has sufficient number of channels for configuration
	{
		ERROR_STREAM << "Invalid channel number in configuration file module : " <<  mod->moduleDescriptor->name << endl;
		EXCEPTION_RETURN("Configurator::ParseConfigLine"," Module " + mod->moduleDescriptor->name + " has less channels than specified in configuration", "Modbus::error_read");
	}

	for(unsigned int i = 1 ; i < lineVals.size(); i++)
	{
		if(lineVals[i].empty()) //if empty skip do not create logical device
			continue;

		LogicalDevice* ld = NULL;
		for(unsigned int j = 0; j < wd->logicalDevices.size(); j++)
		{
			if( wd->logicalDevices[j]->GetName() == lineVals[i])
				ld = wd->logicalDevices[j];
		}
		if(!ld)
		{
			ld =  CreateLogicalDevice(lineVals[i]);
			INFO_STREAM << lineVals[i] << " - Logical Device Created " << endl;
		}

		ld->logicalChannels.push_back(logDeviceValueMapping(mod, i-1));
	}

	return 0;
}

/* Allocate memory for process image buffers in buffer holder.
 *
 */
void Configurator::SetupBuffers()
{
	wd->buffers.numOfDigitalInputs = this->currentBinaryInOffset;
	wd->buffers.numOfCoils = this->currentBinaryOutOffset;
	wd->buffers.numOfHoldingRegisters = this->currentAnaOutOffset;
	wd->buffers.numOfInputRegisters = this->currentAnaInOffset;

	wd->buffers.inputRegisters = new unsigned short[wd->buffers.numOfInputRegisters];
	wd->buffers.holdingRegisters = new unsigned short[wd->buffers.numOfHoldingRegisters];
	wd->buffers.coils = new unsigned short[wd->buffers.numOfCoils];
	wd->buffers.digitalInputs = new unsigned short[wd->buffers.numOfDigitalInputs];

	wd->buffers.coilsWriteBuff = new unsigned short[wd->buffers.numOfCoils];
	wd->buffers.holdingRegistersWriteBuff = new unsigned short[wd->buffers.numOfHoldingRegisters];
	wd->buffers.coilsWriteFlags = new bool[wd->buffers.numOfCoils];
	memset(wd->buffers.coilsWriteFlags, 0x0, wd->buffers.numOfCoils*sizeof(bool));

	wd->buffers.holdingRegistersWriteFlags = new bool[wd->buffers.numOfHoldingRegisters];
	memset(wd->buffers.holdingRegistersWriteFlags, 0x0, wd->buffers.numOfHoldingRegisters*sizeof(bool));

	for(unsigned int i = 0; i < wd->modules.size(); i++ )
	{
		Module *mod = wd->modules[i];
		if(mod->moduleDescriptor->ana_in)
		{
			mod->inputBaseAddr = wd->buffers.inputRegisters + mod->inputOffset;
		}
		if(mod->moduleDescriptor->ana_out)
		{
			mod->outputBaseAddr =  wd->buffers.holdingRegisters + mod->outputOffset;
			mod->outputBaseWriteAddr =  wd->buffers.holdingRegistersWriteBuff + mod->outputOffset;
			mod->outputWriteFlags = wd->buffers.holdingRegistersWriteFlags + mod->outputOffset;
		}
		if(mod->moduleDescriptor->digi_in)
		{
			mod->inputBaseAddr = wd->buffers.digitalInputs + mod->inputOffset;
		}
		if(mod->moduleDescriptor->digi_out)
		{
			mod->outputBaseAddr =  wd->buffers.coils + mod->outputOffset;
			mod->outputBaseWriteAddr =  wd->buffers.coilsWriteBuff + mod->outputOffset;
			mod->outputWriteFlags = wd->buffers.coilsWriteFlags + mod->outputOffset;
		}
	}
}

/* Method for creation and setup of module object representing module other
 * than binary input/output module.
 *
 * \param dsc	pointer to module description structure.
 *
 *  \return 	pointer to created object.
 */
Module* Configurator::CreateRegisterModule(wagoModuleDesc* dsc)
{
	Module* mod;
	if(strncmp(dsc->special.c_str(), M637_RES, strlen(M637_RES)) == 0)
	{
		mod = new M637Module();
	}
	else
	{
		mod = new Module();
	}

	LOGGING_INITIALIZE_ADDON(mod);

	mod->numberOfChannels = dsc->channels;
	mod->numberOfInputs = dsc->ana_in;
	mod->numberOfOutputs = dsc->ana_out;
	wd->modules.push_back(mod);
	return mod;
}

/* Method for creation and setup of module object binary input/output module.
 *
 * \param dsc	pointer to module description structure.
 *
 * \return 	pointer to created object.
 */
Module* Configurator::CreateBinaryModule(wagoModuleDesc* dsc)
{
	Module* mod = new Module();
	LOGGING_INITIALIZE_ADDON(mod);

	mod->numberOfChannels = dsc->channels;
	mod->numberOfInputs = dsc->digi_in;
	mod->numberOfOutputs = dsc->digi_out;
	wd->modules.push_back(mod);
	return mod;
}

/* Method for creation of LgicalDevice Object.
 *
 * \param name	name of logicalDevice Module.
 *
 * \return 	pointer to created object.
 */
LogicalDevice* Configurator::CreateLogicalDevice(string name)
{
	LogicalDevice* ld = new LogicalDevice();
	LOGGING_INITIALIZE_ADDON(ld);

	ld->name = name;
	wd->logicalDevices.push_back(ld);
	return ld;
}

/* Method for for passing modbus connection object (Modbus protocol layer
 * interface object) and process image buffers update cycle time.
 *
 * \param mbdev	pointer to modbus protocol interface object.
 * \param updatePeriod	value of process image buffers update cycle time.
 */
void Configurator::SetModbusDevice(ModbusAbstract *mbDev, unsigned short updatePeriod)
{
	wd->buffers.modbusInterface = mbDev;
	wd->buffers.update_period = updatePeriod;

	if(configValid)
		wd->buffers.StartThread();
	else
	{
		wd->buffers.RetrieveConfig(wd->buffers.devConfiguration);
	}
}
