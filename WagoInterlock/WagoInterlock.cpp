/*----- PROTECTED REGION ID(WagoInterlock.cpp) ENABLED START -----*/
static const char *RcsId = "$Id: WagoInterlock.cpp,v 1.7 2013-09-30 16:15:01 kowalisz Exp $";
//=============================================================================
//
// file :        WagoInterlock.cpp
//
// description : C++ source for the WagoInterlock class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on thef
//               WagoInterlock are implemented in this file.
//
// project :     
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author: kowalisz $
//
// $Revision: 1.7 $
// $Date: 2013-09-30 16:15:01 $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <WagoInterlock.h>
#include <WagoInterlockClass.h>
#include "Attributes.h"
#include "InterlockTools.h"


/*----- PROTECTED REGION END -----*/	//	WagoInterlock.cpp

/**
 *  WagoInterlock class description:
 *    Class representing interlocks implemented using Wago
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  dev_state
//  Status        |  Inherited (no method)
//  UploadConfig  |  upload_config
//  Reset         |  reset
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace WagoInterlock_ns
{
/*----- PROTECTED REGION ID(WagoInterlock::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	WagoInterlock::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::WagoInterlock()
 * Description:  Constructors for a Tango device
 *                implementing the classWagoInterlock
 */
//--------------------------------------------------------
WagoInterlock::WagoInterlock(Tango::DeviceClass *cl, std::string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(WagoInterlock::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::constructor_1
}
//--------------------------------------------------------
WagoInterlock::WagoInterlock(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(WagoInterlock::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::constructor_2
}
//--------------------------------------------------------
WagoInterlock::WagoInterlock(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(WagoInterlock::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::constructor_3
}
//--------------------------------------------------------
WagoInterlock::~WagoInterlock()
{
	delete_device();
}

//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::delete_device()
 * Description:  will be called at device destruction or at init command
 */
//--------------------------------------------------------
void WagoInterlock::delete_device()
{
	DEBUG_STREAM << "WagoInterlock::delete_device() " << device_name << std::endl;
	/*----- PROTECTED REGION ID(WagoInterlock::delete_device) ENABLED START -----*/
	configUploadAllowed = false;

	if(outRelayWagoAttrib)
	{
		delete outRelayWagoAttrib;
		outRelayWagoAttrib = NULL;
	}

	if(wagoDeviceProxyObj)
	{
		delete wagoDeviceProxyObj;
		wagoDeviceProxyObj= NULL;
	}

	for(unsigned int i = 0; i < channelAttributes.size(); i++)
		delete channelAttributes[i];

	channelAttributes.clear();
	attributeMapping.clear();


	interlockInstance = -1;


	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::init_device()
 * Description:  will be called at device initialization.
 */
//--------------------------------------------------------
void WagoInterlock::init_device()
{
	DEBUG_STREAM << "WagoInterlock::init_device() create device " << device_name << std::endl;
	/*----- PROTECTED REGION ID(WagoInterlock::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::init_device_before


	//	Get the device properties from database
	get_device_property();

	//	No longer if mandatory property not set.
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(WagoInterlock::init_device) ENABLED START -----*/
	lastDataCallT = 0;
	lastStatusCallT = 0;
	wagoDeviceProxyObj = NULL;
	configUploadAllowed = false;

	if(CreateDeviceProxy())
		return;

	//Process the interlock flags
	std::string tmp = flags;
	tmp.erase(std::remove(tmp.begin(), tmp.end(), ' '), tmp.end()); // remove whitespaces from line
	std::vector<std::string> fields = string2vector(tmp, ",");
	modeFlags = 0;
	for(unsigned int i = 0 ; i < fields.size(); i++)
	{
		DEBUG_STREAM << "Interlock::init_device() fields[i]: " << fields[i] << std::endl;
		unsigned short fg = FlagsTxt2Bin(fields[i]);
		if(fg == 0x0)
		{
			ERROR_STREAM << "Interlock::init_device() invalid flag " << std::endl;
			this->lastException = CreateException("Invalid interlock flag: " + fields[i], "", "Interlock::init_device()");
			set_state(Tango::UNKNOWN);
			interlockInstance = -1;
			return;
		}
		modeFlags |= fg;
	}
	DEBUG_STREAM << "Interlock::init_device() flags checked:" << std::hex << modeFlags << std::dec << std::endl;

	std::string outRelayAttribName;
	std::vector<unsigned short> addr =  ParseName(outRelay, outRelayAttribName);
	if(addr.size() != 1)
	{
		ERROR_STREAM << "Interlock::init_device() - invalid output relay name syntax" << std::endl;
		this->lastException = CreateException("Invalid output relay name syntax", "", "Interlock::init_device()");
		set_state(Tango::UNKNOWN);
		return;
	}
	outRelayAttribIndex = addr[0];



	//Get the Interlock instance name;
	unsigned short outChan;
	unsigned short mFlags;
	std::vector<channel_t> cConf;

	try
	{
		PrepareRelayOutput(outRelayAttribName);
		ParseConfiguration();
		configUploadAllowed = true;
		interlockInstance = FindInterlock();
		if(interlockInstance == -1)
		{
			Tango::Except::throw_exception("Communication error in init stage",
					"Could not find interlock with given name",
					"WagoInterlock::init_device()");
		}
		RetriveIclkConfig(outChan, mFlags, cConf);
	}catch(const Tango::DevFailed &ex)
	{
		this->lastException = ex;
		ERROR_STREAM << "Interlock::init_device() caught exception while initialization" << std::endl;
		set_state(Tango::UNKNOWN);
		interlockInstance = -1;
		return;
	}

	try{
		ValidateIlckConfig(outChan, mFlags, cConf);
	}catch(const Tango::DevFailed &ex)
	{
		ERROR_STREAM << "Interlock::init_device() configuration INVALID" << std::endl;
		set_state(Tango::UNKNOWN);
		//interlockInstance = -1;
		this->lastException = ex;
		return;
	}

	this->modeFlags = mFlags;

	INFO_STREAM << "Interlock::init_device() configuration valid" << std::endl;

	PrepareWagoAttributeObjs();

	//	Initialize device
	this->set_state(Tango::UNKNOWN);

	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::init_device
}

//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::get_device_property()
 * Description:  Read database to initialize property data members.
 */
//--------------------------------------------------------
void WagoInterlock::get_device_property()
{
	/*----- PROTECTED REGION ID(WagoInterlock::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("config"));
	dev_prop.push_back(Tango::DbDatum("name"));
	dev_prop.push_back(Tango::DbDatum("flags"));
	dev_prop.push_back(Tango::DbDatum("outRelay"));
	dev_prop.push_back(Tango::DbDatum("wagoDevice"));
	dev_prop.push_back(Tango::DbDatum("DataPeriod"));
	dev_prop.push_back(Tango::DbDatum("StatusPeriod"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);

		//	get instance on WagoInterlockClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		WagoInterlockClass	*ds_class =
			(static_cast<WagoInterlockClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize config from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  config;
		else {
			//	Try to initialize config from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  config;
		}
		//	And try to extract config value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  config;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize name from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  name;
		else {
			//	Try to initialize name from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  name;
		}
		//	And try to extract name value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  name;

		//	Try to initialize flags from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  flags;
		else {
			//	Try to initialize flags from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  flags;
		}
		//	And try to extract flags value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  flags;

		//	Try to initialize outRelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  outRelay;
		else {
			//	Try to initialize outRelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  outRelay;
		}
		//	And try to extract outRelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  outRelay;

		//	Try to initialize wagoDevice from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  wagoDevice;
		else {
			//	Try to initialize wagoDevice from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  wagoDevice;
		}
		//	And try to extract wagoDevice value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  wagoDevice;

		//	Try to initialize DataPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dataPeriod;
		else {
			//	Try to initialize DataPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dataPeriod;
		}
		//	And try to extract DataPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dataPeriod;

		//	Try to initialize StatusPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusPeriod;
		else {
			//	Try to initialize StatusPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusPeriod;
		}
		//	And try to extract StatusPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusPeriod;

	}

	/*----- PROTECTED REGION ID(WagoInterlock::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::check_mandatory_property()
 * Description:  For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void WagoInterlock::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << std::endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		append_status(tms.str());
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(WagoInterlock::check_mandatory_property) ENABLED START -----*/
		std::cerr << tms.str() << " for " << device_name << std::endl;
		
		/*----- PROTECTED REGION END -----*/	//	WagoInterlock::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::always_executed_hook()
 * Description:  method always executed before any command is executed
 */
//--------------------------------------------------------
void WagoInterlock::always_executed_hook()
{
	DEBUG_STREAM << "WagoInterlock::always_executed_hook()  " << device_name << std::endl;
	if (mandatoryNotDefined)
	{
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					get_status().c_str(),
					(const char *)"WagoInterlock::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(WagoInterlock::always_executed_hook) ENABLED START -----*/

	//	code always executed before all requests
	
	//check interval from last call if < 1s return previous value
	struct timezone tz;
	struct timeval  cache_update_t;
	gettimeofday(&cache_update_t, &tz);

	__useconds_t interval = (cache_update_t.tv_sec*1000) + (cache_update_t.tv_usec/1000) - lastDataCallT;

	if( interval >= dataPeriod && interlockInstance != -1)
	{
		DEBUG_STREAM << "Interlock::always_executed_hook() performing data Update interval: "<< interval << std::endl;
		try{
			WagoInterlock::UpdateAttributes();
		}catch(Tango::DevFailed &ex){
			ERROR_STREAM << "Interlock::always_executed_hook caught exception in UpdateAttributes() saving to lastException" << std::endl;
			lastException = ex;
		}
		lastDataCallT = (cache_update_t.tv_sec*1000)+ (cache_update_t.tv_usec/1000);
	}
	else
	{
		DEBUG_STREAM << "Interlock::always_executed_hook() skipping data Update interval: "<< interval << std::endl;
	}

	interval = (cache_update_t.tv_sec*1000) + (cache_update_t.tv_usec/1000) - lastStatusCallT;

	if( interval < statusPeriod)
	{
		DEBUG_STREAM << "Interlock::always_executed_hook() skipping status Update interval: " << interval << " lastStatusCallT:" << lastStatusCallT << std::endl;
		return;
	}

	INFO_STREAM << "Interlock::always_executed_hook() performing status Update" << std::endl;
	try{
		WagoInterlock::StatusUpdate();
	}catch(Tango::DevFailed &ex){
		ERROR_STREAM << "Interlock::always_executed_hook() caught exception in StatusUpdate() saving to lastException" << std::endl;
		lastException = ex;
	}
	lastStatusCallT = (cache_update_t.tv_sec*1000)+ (cache_update_t.tv_usec/1000);

	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::read_attr_hardware()
 * Description:  Hardware acquisition for attributes
 */
//--------------------------------------------------------
void WagoInterlock::read_attr_hardware(TANGO_UNUSED(std::vector<long> &attr_list))
{
	DEBUG_STREAM << "WagoInterlock::read_attr_hardware(std::vector<long> &attr_list) entering... " << std::endl;
	/*----- PROTECTED REGION ID(WagoInterlock::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::read_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::add_dynamic_attributes()
 * Description:  Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void WagoInterlock::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(WagoInterlock::add_dynamic_attributes) ENABLED START -----*/

	Tango::Attr *new_attr;

	for(unsigned int i = 0 ; i < this->processedConfiguration.size(); i++ )
	{

		INFO_STREAM << "Interlock::add_dynamic_attributes() InterlockAttribute  - "  << processedConfiguration[i].attributeName << std::endl;
		InterlockAttribute* iAttr = new InterlockAttribute(processedConfiguration[i].attributeName.c_str(),Tango::DEV_FLOAT, Tango::READ);

		Tango::UserDefaultAttrProp* def_prop = new Tango::UserDefaultAttrProp();

		std::stringstream ss;
		ss << processedConfiguration[i].threshold_low;
		def_prop->set_min_alarm(ss.str().c_str());
		ss.str("");

		ss << processedConfiguration[i].threshold_high;
		def_prop->set_max_alarm(ss.str().c_str());
		ss.str("");

		switch(processedConfiguration[i].type)
		{
		case ILCK_TYPE_TC:
			def_prop->set_unit("deg C");
			break;
		case ILCK_TYPE_IV:
		case ILCK_TYPE_OV:
			def_prop->set_unit("V");
			break;
		}


		iAttr->set_default_properties(*def_prop);

		attributes.push_back(iAttr);
		add_attribute(iAttr);

	}

	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command State related method
 * Description:  This command gets the device state (stored in its device_state data member) and returns it to the caller.
 *
 *	@returns Device state
 */
//--------------------------------------------------------
Tango::DevState WagoInterlock::dev_state()
{
	DEBUG_STREAM << "WagoInterlock::State()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(WagoInterlock::dev_state) ENABLED START -----*/

	Tango::DevState	argout;
	//	Add your own code

	if(this->interlockInstance == -1 || !configOK || this->modeFlags & IL_CNF_ERR || this->modeFlags & IL_HDW_ERR || !this->wagoDeviceProxyObj || GetWagoSrvState() == Tango::FAULT)
	{
		DEBUG_STREAM << "Interlock::State() configOK == false state set to Tango::UNKNOWN" << std::endl;
		argout = Tango::UNKNOWN;
	}
	else if(!CheckChannelsValidity() ||  this->modeFlags & IL_ALARM  ) //TODO this->modeFlags & IL_ALARM is this needed ??
	{
		DEBUG_STREAM << "Interlock::State() CheckChannelsValidity or Wago state invalid setting state to Tango::ALARM" << std::endl;
		argout = Tango::ALARM;
	}
	else
	{
		float intlckVal;
		try{
			outRelayWagoAttrib->readAttribute(wagoDeviceProxyObj);
			intlckVal = outRelayWagoAttrib->at(outRelayAttribIndex);

			DEBUG_STREAM << "Interlock::dev_state() read relay  " << outRelay << "  value " << intlckVal << std::endl;


			bool interlockTriggered = intlckVal > 0 ? false : true; //Output set to 1 means that interlock is not activated 0 - interlock tripped.
			if(modeFlags & IL_INVERTED)								// unless inverted flag is set
				interlockTriggered = !interlockTriggered;

			if( outRelayWagoAttrib->getQuality() != Tango::ATTR_VALID)
			{

				this->lastException = CreateException("Relay output attribute has invalid quality", "", "Interlock::State()");

				DEBUG_STREAM << "Interlock::State() relay output attribute has invalid quality setting state to Tango::ALARM" << std::endl;
				argout = Tango::ALARM;
			}
			else if(interlockTriggered || this->modeFlags & IL_TRIP)
			{
				DEBUG_STREAM << "Interlock::State() interlock is trigered state to Tango::FAULT" << std::endl;
				argout = Tango::FAULT;
			}
			else
			{
				DEBUG_STREAM << "Interlock::State() setting state to Tango::ON" << std::endl;
				argout = Tango::ON;
			}
		}catch(Tango::DevFailed &ex)
		{
			ERROR_STREAM << "Interlock::dev_state() exception while reading relay: "<< outRelay << std::endl;
			lastException = ex;
			argout = Tango::UNKNOWN;
		}
	}
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::dev_state
	set_state(argout);    // Give the state to Tango.
	if (argout!=Tango::ALARM)
		Tango::DeviceImpl::dev_state();
	return get_state();  // Return it after Tango management.
}
//--------------------------------------------------------
/**
 *	Command UploadConfig related method
 * Description:  Uploads configuration to controller
 *
 */
//--------------------------------------------------------
void WagoInterlock::upload_config()
{
	DEBUG_STREAM << "WagoInterlock::UploadConfig()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(WagoInterlock::upload_config) ENABLED START -----*/

	interlockInstance = -1;

	if(!wagoDeviceProxyObj)
	{
		Tango::Except::throw_exception("Communication error",
				"No connection to wago server",
				"Interlock::upload_config()");
	}

	if(!configUploadAllowed)
	{
		Tango::Except::throw_exception("Server properties does not match to internal configuration",
				"Invalid configuration syntax upload is not allowed",
				"Interlock::upload_config()");
	}

	try{
		Tango::DeviceData indat, outdat;

		std::vector<short> requestBuffer;

		int existingInst;
		do
		{
			existingInst = FindInterlock(); //if interlock already exists delete it
			if(existingInst != -1)
			{
				INFO_STREAM << "Interlock::UploadConfig()  -  existing instance found deleting !!!" << std::endl;
				requestBuffer.resize(2);
				requestBuffer[0] = ILCK_DELETE;
				requestBuffer[1] = (unsigned short)existingInst;
				indat <<  requestBuffer;
				wagoDeviceProxyObj->command_inout("DevWcComm", indat);
			}else
				INFO_STREAM << "Interlock::UploadConfig()  - no existing instance found !" << std::endl;
		}while(existingInst != -1);

		std::string relayName;
		std::vector<unsigned short> addr =  ParseName(outRelay, relayName);
		if(addr.size() != 1)
		{
			ERROR_STREAM << "Interlock::UploadConfig()  - Invalid ouput relay name" << std::endl;
			Tango::Except::throw_exception("Server outChan property does not match to internal configuration.",
					"Invalid ouput relay name",
					"Interlock::upload_config()");
		}
		unsigned short logicalChannel = addr[0];


		//Get offset to output relay device
		indat <<  relayName;
		outdat = wagoDeviceProxyObj->command_inout("DevName2Key", indat);
		short devKey;
		outdat >> devKey;
		DEBUG_STREAM << "Interlock::UploadConfig() DevName2Key returned key : " <<  devKey << std::endl;

		requestBuffer.resize(2);
		requestBuffer[0] = devKey;
		requestBuffer[1] = logicalChannel;
		indat << requestBuffer;
		outdat = wagoDeviceProxyObj->command_inout("DevLog2Hard", indat);
		outdat >> requestBuffer;

		if(requestBuffer[1] != (('O'<<8)+'B'))
		{
			ERROR_STREAM << "Interlock::UploadConfig()  - invalid ouptu channel type !" << std::endl;
			Tango::Except::throw_exception("Server outChan property does not match to internal configuration.",
					"Invalid output channel type",
					"Interlock::upload_config()");
		}
		unsigned short outSharedOff = requestBuffer[0];


		requestBuffer.resize(3);
		requestBuffer[0] = ILCK_CREATE;
		requestBuffer[1] = outSharedOff;
		requestBuffer[2] = modeFlags;
		indat <<  requestBuffer;
		outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
		outdat >> requestBuffer;
		interlockInstance = requestBuffer[0];
		outputChannel = outSharedOff;
		DEBUG_STREAM << "Interlock::UploadConfig() interlockInstance = " << interlockInstance << std::endl;//*/interlockInstance=1;

		// Set name
		requestBuffer.resize(2);
		requestBuffer[0] = ILCK_SETNAME;
		requestBuffer[1] = interlockInstance;
		DEBUG_STREAM << "Interlock::UploadConfig() interlock name:" << this->name;


		unsigned int i;
		std::vector<unsigned short> packedName =  PackString(this->name);
		for(i = 0 ; i < packedName.size(); i++ )
			DEBUG_STREAM << "packedName[" << i << "] = " << std::hex << packedName[i] << std::dec << std::endl;
		requestBuffer.insert( requestBuffer.end(), packedName.begin(), packedName.end() );


		for(i = 0 ; i < requestBuffer.size(); i++ )
			DEBUG_STREAM << "requestBuffer[" << i << "] = " << std::hex << requestBuffer[i] << std::dec << std::endl;

		indat <<  requestBuffer;

		outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
		indat = outdat;

		DEBUG_STREAM << "Interlock::UploadConfig() setting up interlock channels"<< std::endl;
		for(i = 0; i < processedConfiguration.size(); i++)
		{

			indat <<  processedConfiguration[i].name;
			outdat = wagoDeviceProxyObj->command_inout("DevName2Key", indat);

			short devKey;
			outdat >> devKey;
			DEBUG_STREAM << "Interlock::UploadConfig() DevName2Key returned key : " <<  devKey << std::endl;
			requestBuffer[0] = devKey;
			requestBuffer[1] = processedConfiguration[i].logicalChannel;
			indat << requestBuffer;

			outdat = wagoDeviceProxyObj->command_inout("DevLog2Hard", indat);

			outdat >> requestBuffer;
			DEBUG_STREAM << "Interlock::UploadConfig() DevLog2Hard returned offset : 0x" << std::hex <<  requestBuffer[0] << std::dec << std::endl;

			processedConfiguration[i].channelProcImgOffset = requestBuffer[0]; //Channel number for WcComm Add Channel is in fact offset
			unsigned short type = requestBuffer[1];

			requestBuffer.clear();
			requestBuffer.push_back(ILCK_ADDCHAN);
			requestBuffer.push_back(interlockInstance);
			requestBuffer.push_back(processedConfiguration[i].flags);
			requestBuffer.push_back(processedConfiguration[i].channelProcImgOffset);
			if((type & 'W') == 'W')//this is not binnary threshold values required
			{

				requestBuffer.push_back(
						DoReverseScaling(processedConfiguration[i].threshold_low, processedConfiguration[i].type));

				requestBuffer.push_back(
						DoReverseScaling(processedConfiguration[i].threshold_high, processedConfiguration[i].type));

				requestBuffer.push_back(processedConfiguration[i].type);
			}

			DEBUG_STREAM << "Interlock::UploadConfig() Sending DevWcComm request to add interlock channel" << std::endl;
			DEBUG_STREAM << "requestBuffer[0] = " << requestBuffer[0] << std::endl;
			DEBUG_STREAM << "requestBuffer[1] = " << requestBuffer[1] << std::endl;
			DEBUG_STREAM << "requestBuffer[2] = " << requestBuffer[2] << std::endl;
			DEBUG_STREAM << "requestBuffer[3] = " << requestBuffer[3] << std::endl;
			if((type & 'W') == 'W')	//this is not binnary threshold values required
			{
				DEBUG_STREAM << "requestBuffer[4] = " << requestBuffer[4] << std::endl;
				DEBUG_STREAM << "requestBuffer[5] = " << requestBuffer[5] << std::endl;
				DEBUG_STREAM << "requestBuffer[6] = " << requestBuffer[6] << std::endl;
			}
			indat <<  requestBuffer;
			wagoDeviceProxyObj->command_inout("DevWcComm", indat);

		}
	}catch(Tango::DevFailed &ex)
	{
		interlockInstance = -1;
		throw ex;
	}

	lastException.errors.length(0);
	PrepareWagoAttributeObjs();
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::upload_config
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 * Description:  Resets the instance controller (in case of sticky channels)
 *
 */
//--------------------------------------------------------
void WagoInterlock::reset()
{
	DEBUG_STREAM << "WagoInterlock::Reset()  - " << device_name << std::endl;
	/*----- PROTECTED REGION ID(WagoInterlock::reset) ENABLED START -----*/
	
	Tango::DeviceData indat, outdat;
	std::vector<short> requestBuffer;
	INFO_STREAM << "Interlock::Reset()  - interlockInstance: " << interlockInstance << std::endl;
	requestBuffer.resize(2);
	requestBuffer[0] = ILCK_RESET;
	requestBuffer[1] = interlockInstance;
	indat <<  requestBuffer;
	outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
	outdat >> requestBuffer;
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::reset
}
//--------------------------------------------------------
/**
 *	Method      : WagoInterlock::add_dynamic_commands()
 * Description:  Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void WagoInterlock::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(WagoInterlock::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	WagoInterlock::add_dynamic_commands
}

/*----- PROTECTED REGION ID(WagoInterlock::namespace_ending) ENABLED START -----*/

/*!Create interface object to wago server and setup timeout.
 *
 * \return -1 if failed, 0 if success.
 */
int WagoInterlock::CreateDeviceProxy()
{
	try
	{
		wagoDeviceProxyObj = new Tango::DeviceProxy(wagoDevice);
		wagoDeviceProxyObj->set_timeout_millis(1000);
	}
	catch(const Tango::DevFailed &ex)
	{
		Tango::Except::print_exception(ex);

		ERROR_STREAM << "Interlock::CreateDeviceProxy() error during creation of device proxy to Wago device server."<< std::endl;
		ERROR_STREAM << "Setting state to UNKNOWN" << std::endl;
		this->lastException = ex;
		this->set_state(Tango::UNKNOWN);
		wagoDeviceProxyObj = NULL;
		return -1;
	}
	return 0;
}

/*!Informs tango library if reading of attribute is allowed.
 *
 * \return true if allowed, false if not.
 */
bool WagoInterlock::is_read_attribute_allowed(Tango::AttReqType ty)
{
	if(get_state() == Tango::UNKNOWN)
		return false;

	return true;
}


/*!Download list of interlocks set up on wago controller and try to
 * find interlock given by name given in name property of server. Method sets
 * interlock intance number.
 *
 * \return found itnerlock instance number, if interlock not found -1.
 */
int WagoInterlock::FindInterlock()
{
	Tango::DeviceData indat, outdat;
	std::vector<short> requestBuffer;

	requestBuffer.resize(2);
	requestBuffer[0] = CMD_ACTIVE;
	requestBuffer[1] = FUNC_INTERLOCK;

	try{
		indat <<  requestBuffer;
		outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
		outdat >> requestBuffer;
	}catch(Tango::DevFailed &ex)
	{
		ERROR_STREAM << "WagoInterlock::FindInterlock() Error getting number of interlocks in device" << std::endl;
		Tango::Except::re_throw_exception(ex,
				"Communication error in init stage",
				"Error getting number fo interlocks in device",
				"WagoInterlock::FindInterlock()");
	}

	int numOfInstancesToCheck = requestBuffer[2];
	DEBUG_STREAM <<  "Interlock::FindInterlock() from response numOfInstancesToCheck: " << numOfInstancesToCheck << std::endl;

	int instance = -1;
	for(int i = 1; i<= numOfInstancesToCheck; i++) // instances are numbered starting from 1 in controller.
	{
		requestBuffer.resize(2);
		requestBuffer[0] = ILCK_GETNAME;
		requestBuffer[1] = i;
		try{
			indat <<  requestBuffer;
			outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
			outdat >> requestBuffer;
		}catch(const Tango::DevFailed &ex)
		{
			continue;
		}
			
		if(!requestBuffer.size())
			continue;

		std::string icName = UnpackString(requestBuffer);
		DEBUG_STREAM << "Interlock::FindInterlock() interlock: " << icName << " instance: " << i << std::endl;

		if(this->name == icName)
		{
			INFO_STREAM << "Interlock::FindInterlock() Found interlock  id:" << i << std::endl;
			instance = i;
		}
	}

	if(instance == -1)
	{
		INFO_STREAM << "Interlock::FindInterlock() none interlock instance found" << std::endl;
	}
		
	return instance;
}

/*! Compare the given interlock configuration with config stored in server object, if configs are different
 * method throws exception.
 *
 * \param outChan output channel identifier.
 * \param mFalags interlock flags.
 * \param cConf	vector holding configuration of interlock channels.
 */
void WagoInterlock::ValidateIlckConfig(unsigned short &outChan, unsigned short &mFlags, std::vector<channel_t> &cConf)
{
	if(outChan != this->outputChannel)
	{
		this->configOK = false;
		ERROR_STREAM << "Interlock::ValidateIlckConfig output channel does not match" << std::endl;
		Tango::Except::throw_exception("Server outRelay property does not match to internal configuration",
				"output channel does not match",
				"Interlock::ValidateIlckConfig()");
	}

	DEBUG_STREAM << "Interlock::ValidateIlckConfig() (mFlags & IL_MODE_MASK): " << std::hex << (mFlags & IL_MODE_MASK) << " this->modeFlags: " << std::hex <<  this->modeFlags << std::dec << std::endl;
	if((mFlags & IL_MODE_MASK) != (this->modeFlags& IL_MODE_MASK))
	{
		this->configOK = false;
		ERROR_STREAM << "Interlock::ValidateIlckConfig interlock flags does not match" << std::endl;
		Tango::Except::throw_exception("Server flags property does not match to internal configuration",
				"interlock flags does not match",
				"Interlock::ValidateIlckConfig()");
	}

	if(cConf.size() != processedConfiguration.size())
	{

		this->configOK = false;
		ERROR_STREAM << "Interlock::ValidateIlckConfig() Number of interlock channels des not match with device" << std::endl;
		Tango::Except::throw_exception("Config property != embedded configuration",
				"Number of interlock channels des not match with device",
				"Interlock::ValidateIlckConfig()");
	}

	for(unsigned int i = 0; i < processedConfiguration.size(); i++ )
	{
		if( (cConf[i].flags & IL_MODE_MASK) != processedConfiguration[i].flags)
		{
			this->configOK = false;
			std::stringstream ss;
			ss << i;
			ERROR_STREAM << "Interlock::ValidateIlckConfig() channel " << i <<  "channel config flags does not match" << std::endl;
			ERROR_STREAM << "flags in device: 0x" << std::hex << cConf[i].flags << " "<<  std::dec;
			ERROR_STREAM << "flags in config: 0x" << std::hex << processedConfiguration[i].flags << std::dec << std::endl;
			Tango::Except::throw_exception("channel " + ss.str() + "config flags does not match",
						"",
						"Interlock::ValidateIlckConfig()");
		}

		DEBUG_STREAM << "Interlock::ValidateIlckConfig channel offset got from device: " << std::hex << cConf[i].channelProcImgOffset << std::dec << std::endl;
		DEBUG_STREAM << "Interlock::ValidateIlckConfig channel offset calculated from config: " << std::hex << processedConfiguration[i].channelProcImgOffset << std::dec << std::endl;
		if(cConf[i].channelProcImgOffset != processedConfiguration[i].channelProcImgOffset)
		{
			this->configOK = false;
			ERROR_STREAM << "Interlock::ValidateIlckConfig " << processedConfiguration[i].attributeName  << " channel does not match" << std::endl;
			Tango::Except::throw_exception("Config property != embedded configuration",
					processedConfiguration[i].attributeName + " channel does not match",
					"Interlock::ValidateIlckConfig()");
		}

		if(!(cConf[i].flags & IL_DIGITAL))
		{
			if(cConf[i].threshold_low != processedConfiguration[i].threshold_low)
			{
				this->configOK = false;
				ERROR_STREAM << "Interlock::ValidateIlckConfig " << processedConfiguration[i].attributeName  << " threshold low does not match" << std::endl;
				Tango::Except::throw_exception("Config property != embedded configuration",
						"Wrong "+ processedConfiguration[i].attributeName + " threshold low level",
						"Interlock::ValidateIlckConfig()");
			}

			if(cConf[i].threshold_high != processedConfiguration[i].threshold_high)
			{
				this->configOK = false;
				ERROR_STREAM << "Interlock::ValidateIlckConfig " << processedConfiguration[i].attributeName  << " threshold high does not match" << std::endl;
				Tango::Except::throw_exception("Config property != embedded configuration",
						"Wrong "+ processedConfiguration[i].attributeName + " threshold high level",
						"Interlock::ValidateIlckConfig()");
			}

			if(cConf[i].type != processedConfiguration[i].type)
			{
				this->configOK = false;
				ERROR_STREAM << "Interlock::ValidateIlckConfig " << processedConfiguration[i].attributeName  << " type does not match" << std::endl;
				Tango::Except::throw_exception("Config property != embedded configuration",
						"Wrong "+ processedConfiguration[i].attributeName + " type",
						"Interlock::ValidateIlckConfig()");

			}
		}
	}

	INFO_STREAM << "Interlock::ValidateIlckConfig Config is valid" << std::endl;
	this->configOK = true;
}

/*!Dwonload interlock configuration from Wago controller.
 *
 * \param outChan 	a place holder for output channel identifier.
 * \param mFlags	a place holder for interlog flags.
 * \param cConf		a place holder for interlock channels configuration.
 *
 */
void WagoInterlock::RetriveIclkConfig(unsigned short &outChan, unsigned short &mFlags, std::vector<channel_t> &cConf)
{
	channel_t tmp;

	cConf.clear();
	Tango::DeviceData indat, outdat;
	std::vector<short> requestBuffer;

	requestBuffer.resize(2);
	requestBuffer[0] = ILCK_GETCONF;
	requestBuffer[1] = interlockInstance;
	DEBUG_STREAM << "Interlock::RetriveIclkConfig() interlockInstance" << interlockInstance  <<  std::endl;

	try{
		indat <<  requestBuffer;
		outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
		outdat >> requestBuffer;
	}catch(Tango::DevFailed &ex)
	{
		ERROR_STREAM << "WagoInterlock::RetriveIclkConfig() Error while retreiving interlock configuration" << std::endl;
		Tango::Except::re_throw_exception(ex,
				"Error while updating interlock status",
				"Error while retrieving interlock configuration",
				"WagoInterlock::RetriveIclkConfig()");

	}

	outChan = requestBuffer[0];
	mFlags = requestBuffer[1];
	int numOfChannels = requestBuffer[2];
	DEBUG_STREAM << "Interlock::RetriveIclkConfig() retrived number of channels = " << numOfChannels << std::endl;

	for(int i = 1; i<= numOfChannels; i++) // instances are numbered starting from 1 in controller.
	{
		requestBuffer.resize(3);
		requestBuffer[0] = ILCK_GETCONF;
		requestBuffer[1] = interlockInstance;
		requestBuffer[2] = i;

		try{
			indat <<  requestBuffer;
			outdat = wagoDeviceProxyObj->command_inout("DevWcComm", indat);
			outdat >> requestBuffer;
		}catch(Tango::DevFailed &ex)
		{
			ERROR_STREAM << "WagoInterlock::RetriveIclkConfig() Error while retreiving configuration for interlock channel " << i << std::endl;
			Tango::Except::re_throw_exception(ex,
					"Error while updating interlock status",
					"Error while retrieving configuration for interlock channel",
					"WagoInterlock::RetriveIclkConfig()");
		}

		memset(&tmp, sizeof(tmp), 0x0);
		tmp.flags = requestBuffer[0];
		tmp.channelProcImgOffset = requestBuffer[1];
		if(!(tmp.flags & IL_DIGITAL) && requestBuffer.size() >= 5)
		{
			tmp.type = requestBuffer[4];

			tmp.threshold_low = DoScaling(requestBuffer[2], tmp.type);
			tmp.threshold_high = DoScaling(requestBuffer[3], tmp.type);
		}

		cConf.push_back(tmp);
	}

}

/*!Processes the text configuration of interlock written in server properties. If error
 * ocurres during configuration processing exception will be thrown.
 *
 */
void WagoInterlock::ParseConfiguration()
{
	channel_t buffer;
	processedConfiguration.clear();

	for(unsigned int i = 0; i < config.size(); i++)
	{
		std::string tmp = config[i];
		tmp.erase(std::remove(tmp.begin(), tmp.end(), ' '), tmp.end()); // remove whitespaces from line
		std::vector<std::string> fields = string2vector(tmp, ",");

		std::vector<unsigned short> addr =  ParseName( fields[0], buffer.name);
		if(!addr.size())
		{
			ERROR_STREAM <<	"Interlock::ParseConfiguration() invalid input channel name syntax: "<< fields[0] << std::endl;
			Tango::Except::throw_exception("Error in server property: config. ",
					fields[0] + ": invalid input channel name syntax",
					"Interlock::ParseConfiguration()");
		}
		buffer.logicalChannel = addr[0];

		//Set neme depending if wago server variable is scalar or vector.
		if(addr.size()!=2 )
		{
			buffer.attributeName = fields[0];
		}else
		{
			std::stringstream iss;
			iss << buffer.logicalChannel;
			buffer.attributeName = buffer.name + "[" + iss.str() + "]";
		}


		buffer.type = (((unsigned short)fields[1].at(0)) << 8 ) | ((unsigned short)fields[1].at(1)); //Channel type

		//Type validity check
		if(buffer.type != ILCK_TYPE_TC &&
				buffer.type != ILCK_TYPE_TC	&&
				buffer.type != ILCK_TYPE_IV	&&
				buffer.type != ILCK_TYPE_OV	&&
				buffer.type != ILCK_TYPE_IW	&&
				buffer.type != ILCK_TYPE_OW	&&
				buffer.type != ILCK_TYPE_IB	&&
				buffer.type != ILCK_TYPE_OB	)
		{
			processedConfiguration.clear();
			ERROR_STREAM <<	"Interlock::ParseConfiguration() Channel " << buffer.name << " has invalid type " << fields[1] << std::endl;
			Tango::Except::throw_exception("Error in server property: config",
					"Channel" + buffer.name + " has invalid type " + fields[1],
					"Interlock::ParseConfiguration()");

		}

		if(buffer.type != ILCK_TYPE_OB && buffer.type != ILCK_TYPE_IB)
		{
			if(fields.size() < 4)
			{
				processedConfiguration.clear();
				ERROR_STREAM << "Interlock::ParseConfiguration() Channel " << buffer.name << " - threshold levels are required "<< std::endl;
				Tango::Except::throw_exception("Error in server property: config",
						"Interlock channel " + buffer.name + " - threshold levels are required ",
						"Interlock::ParseConfiguration()");

			}

			float thrVal;
			thrVal = atoi(fields[2].c_str());
			buffer.threshold_low = thrVal; //LOW_TH

			thrVal = atoi(fields[3].c_str());
			buffer.threshold_high = thrVal; //HIGH_TH
		}


		buffer.flags = 0x0;
		for(unsigned int j = 4; j < fields.size(); j++ )
		{
			buffer.flags |= FlagsTxt2Bin(fields[j]);
		}

		try{

			buffer.channelProcImgOffset = GetAttrAffsetOffset(buffer.name, buffer.logicalChannel);

			processedConfiguration.push_back(buffer);

			if(addr.size() == 2)
			{
				for(unsigned int j = addr[0]+1; j <= addr[2]; j++)
				{
					std::stringstream iss;
					buffer.logicalChannel = j;
					iss << j;
					buffer.attributeName = buffer.name + "[" + iss.str() + "]";
					buffer.channelProcImgOffset = GetAttrAffsetOffset(buffer.name, buffer.logicalChannel);
					processedConfiguration.push_back(buffer);
				}
			}
		}catch(Tango::DevFailed &ex)
		{
			ERROR_STREAM << "Interlock::ParseConfiguration() Channel " << buffer.attributeName << " - attribute not found in wago server "<< std::endl;
			Tango::Except::re_throw_exception(ex,
					"Error in server property: config",
					"Interlock channel " + buffer.attributeName + " - could not find attribute in wago server ",
					"Interlock::ParseConfiguration()");
		}
	}
}


/*! Setup interface to Wago server attribute representing relay output of interlock.
 *
 *	\param outRelayAttribName	name of attribute in wago server representing interlock ouput relay.
 */
void WagoInterlock::PrepareRelayOutput(std::string outRelayAttribName)
{
	Tango::AttributeInfoList *wAttrInfo;
	std::vector<std::string> tmpNamList;

	tmpNamList.push_back(outRelayAttribName);
	outRelayWagoAttrib = NULL;
	try{
		wAttrInfo = this->wagoDeviceProxyObj->get_attribute_config(tmpNamList);
		this->outputChannel = GetAttrAffsetOffset(outRelayAttribName, outRelayAttribIndex);
	}catch(Tango::DevFailed &ex)
	{
		if(wAttrInfo)
			delete wAttrInfo;

		Tango::Except::re_throw_exception(ex,
				"Error in server property outRelay :",
				"Interlock output channel " + outRelay + " - could not find attribute in wago server ",
				"Interlock::init_device()");
	}
	outRelayWagoAttrib = new WagoAttribute(outRelayAttribName,(*wAttrInfo)[0].max_dim_x);

	delete wAttrInfo;
}

/*! Setup objects representing attributes of Wago server.
 *
 */
void WagoInterlock::PrepareWagoAttributeObjs()
{
	Tango::Attr *new_attr;

	std::vector<std::string> *wAttrNameList = wagoDeviceProxyObj->get_attribute_list();
	Tango::AttributeInfoList *wAttrInfo = wagoDeviceProxyObj->get_attribute_config(*wAttrNameList);

	std::cout << " ProcessedConfiguration size: " << this->processedConfiguration.size() << std::endl;
	for(unsigned int i = 0 ; i < this->processedConfiguration.size(); i++ )
	{
		DEBUG_STREAM << "Interlock::add_dynamic_attributes() searching for attribute named " << processedConfiguration[i].name << std::endl;
//		std::cout << "Interlock::add_dynamic_attributes() searching for attribute named " << processedConfiguration[i].name << std::endl;

		Tango::AttributeInfo *inf = NULL;

		for(unsigned int j =0 ; j < wAttrInfo->size(); j++)
		{
			if((*wAttrInfo)[j].name == processedConfiguration[i].name)
			{
				inf = &(*wAttrInfo)[j];
				break;
			}
		}

		if(!inf)
		{
			ERROR_STREAM << "Interlock::add_dynamic_attributes() attribute: " << processedConfiguration[i].name <<  "not found on wago server"<< std::endl;
			return;
		}


		// check if wago attribute object already exists (used with spectrum attributes)
		WagoAttribute *new_attr = NULL;
		for(unsigned int j = 0; j < channelAttributes.size(); j++)
		{
			if(channelAttributes[j]->getName() == processedConfiguration[i].name)
			{
				new_attr = channelAttributes[j];
				break;
			}
		}
		if(new_attr == NULL)
 		{
			int dimension =   inf->max_dim_x;
			INFO_STREAM << "Interlock::add_dynamic_attributes()  - WagoAttribute" << processedConfiguration[i].name << std::endl;
			new_attr = new WagoAttribute(processedConfiguration[i].name, dimension);
			channelAttributes.push_back(new_attr);
		}
		std::cout << " Create attribute " << new_attr->getName() << std::endl;
		wagoAttrMapping_t attrMapBuf;
		attrMapBuf.wAttr = new_attr;
		attrMapBuf.position = processedConfiguration[i].logicalChannel;
		attributeMapping.insert(make_pair(processedConfiguration[i].attributeName, attrMapBuf));

	}

	delete wAttrNameList;
	delete wAttrInfo;
}

/*! Get the state of wago Tango server.
 *
 * \return status of wago server.
 */
Tango::DevState WagoInterlock::GetWagoSrvState()
{
	Tango::DeviceAttribute dAttr;
	try{
		dAttr = wagoDeviceProxyObj->read_attribute("State");
		Tango::DevState state;
		dAttr >> state;
		return state;
	}catch(const Tango::DevFailed &ex)
	{
		ERROR_STREAM << "Interlock::GetWagoSrvState() - catched exception while reading state of Wago server" << std::endl;
		this->lastException = AddToException(ex,"Error while device polling", "Catched exception while reading state of Wago server", "Interlock::GetWagoSrvState()");
		return Tango::UNKNOWN;
	}
}

/*!Check validity of attributes representing channels of interlock.
 *
 * \return true if all channels are valid otherwise false.
 */
bool WagoInterlock::CheckChannelsValidity()
{

	for(unsigned int i =0; i < channelAttributes.size(); i++)
	{
		if(channelAttributes[i]->getQuality() == Tango::ATTR_INVALID)
			return false;
	}

	return true;
}

/*! Initialize read of attribute values from wago Tango server.
 *
 */
void WagoInterlock::UpdateAttributes()
{

	for(unsigned int i = 0; i < channelAttributes.size(); i++)
	{
		channelAttributes[i]->readAttribute(this->wagoDeviceProxyObj);
	}
}

/*!Update status of the interlock server. Method obtains interlock configuration
 * from wago controller does consistency check with configuration of the interlock
 * server and updates status attribute of server.
 */
void WagoInterlock::StatusUpdate()
{
	unsigned short outChan;
	unsigned short mFlags;
	std::vector<channel_t> cConf;

	std::stringstream ss;
	ss << "Interlock instance: " << interlockInstance << std::endl;

	try{
		if(wagoDeviceProxyObj && (this->interlockInstance != -1))
		{
			RetriveIclkConfig(outChan, mFlags, cConf);
			ValidateIlckConfig(outChan, mFlags, cConf);
			this->modeFlags = mFlags;

			ss << FlagsBin2Txt(mFlags) << std::endl;
			ss << "Interlock channel: " << outChan << " on " << cConf.size() << " input channels" << std::endl;
			for(unsigned int i = 0; i < cConf.size(); i++)
			{
				if(i < processedConfiguration.size())
					ss << processedConfiguration[i].attributeName;
				ss << ": " ;
				ss << "type " << (char)(cConf[i].type>>8) << (char)(cConf[i].type & 0x00ff) << ", ";
				ss << "low " << cConf[i].threshold_low << ", ";
				ss << "high " << cConf[i].threshold_high;
				ss << "-> " << FlagsBin2Txt(cConf[i].flags);
				if( !(cConf[i].flags & IL_ALARM) && !(cConf[i].flags & IL_TRIP) )
					ss << " OK";
				ss << std::endl;


			}
		}

	}catch(Tango::DevFailed &ex)
	{
		lastException = AddToException(ex,"Error while device status update", "Cannot initialize","Interlock::StatusUpdate()");
		configOK = false;
		ERROR_STREAM << "Interlock::dev_status() StatusUpdate catched exception" << std::endl;
	}

	if(lastException.errors.length() && (get_state() != Tango::ON))
	{
		ss << "configuration mismatch, try UploadConfig\n";
		ss << "================================" << std::endl;
		//ss << "Last Exception:\n";
		for (unsigned short i = 0; i< lastException.errors.length(); i++)
		{
			//ss << "\t" << lastException.errors[i].origin.in();
			//ss << std::endl;
			ss << lastException.errors[i].desc.in();
			ss << std::endl;
			ss << lastException.errors[i].reason.in();
			ss << std::endl;
			ss << "================================" << std::endl;
		}
		ss << "\n";
	}
	set_status(ss.str());
}

/*!Method reads the process image offset of attribute given by its name and logical channel.
 *  If error occurs during reading process exception will be thrown
 *
 * \param wagoAttributeName	name of wago attribute
 * \param logicalChannel	logical channel
 *
 * \return found offset
 */
unsigned short WagoInterlock::GetAttrAffsetOffset(std::string wagoAttributeName, unsigned short logicalChannel)
{
	Tango::DeviceData indat, outdat;
	std::vector<short> requestBuffer;
	unsigned short channelProcImgOffset;

	try{
		indat <<  wagoAttributeName;
		outdat = wagoDeviceProxyObj->command_inout("DevName2Key", indat);
	}catch(Tango::DevFailed &ex)
	{
		ERROR_STREAM << "WagoInterlock::WriteChannelOffset could not find attribute " << wagoAttributeName << " in wago server" << std::endl;
		Tango::Except::throw_exception("Communication error in init stage",
				"Could not find attribute " + wagoAttributeName + " in wago server",
				"WagoInterlock::WriteChannelOffset()");
	}

	short devKey;
	outdat >> devKey;
	DEBUG_STREAM << "WagoInterlock::WriteChannelOffset() DevName2Key returned key : " <<  devKey << std::endl;
	requestBuffer.resize(2);
	requestBuffer[0] = devKey;
	requestBuffer[1] = logicalChannel;
	indat << requestBuffer;

	try{
		outdat = wagoDeviceProxyObj->command_inout("DevLog2Hard", indat);
	}catch(Tango::DevFailed &ex)
	{
		std::stringstream ss;
		ss << logicalChannel;
		ERROR_STREAM << "WagoInterlock::WriteChannelOffset could not find logicalChannel " << ss.str()  << " of attribute " << wagoAttributeName << " in wago server" << std::endl;
		Tango::Except::throw_exception("Communication error in init stage",
				"Could not find logical channel " + ss.str() + " of attribute " + wagoAttributeName + " in wago server",
				"WagoInterlock::WriteChannelOffset()");
	}

	outdat >> requestBuffer;
	DEBUG_STREAM << "WagoInterlock::WriteChannelOffset() DevLog2Hard returned offset : 0x" << std::hex <<  requestBuffer[0] << std::dec << std::endl;

	channelProcImgOffset = requestBuffer[0]; //Channel number for WcComm Add Channel is in fact offset

	return channelProcImgOffset;
}
/*! Method for supply corresponding value to given interlock attribute.
 *
 *	\param att	reference to interlock attribute which is a subject of request.
 */
void WagoInterlock::read_attr(Tango::Attribute &att)
{
	std::map<std::string, wagoAttrMapping_t>::iterator it =  attributeMapping.find(att.get_name());
	if( it != attributeMapping.end())
	{
		att.set_value((it->second).wAttr->at_ptr((it->second).position));
		att.set_quality((it->second).wAttr->getQuality());
	}
	else
	{
	Tango::Except::throw_exception("Attribute not found" ,
				"Could not find attribute " + att.get_name() + " in read attribute",
				"WagoInterlock::read_attr()");
	}
	
}

/*----- PROTECTED REGION END -----*/	//	WagoInterlock::namespace_ending
} //	namespace
